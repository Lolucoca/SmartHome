
AVRLoRaDevBoard.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000008  00806000  00000cb2  00000d46  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00000cb2  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          000000be  00806008  00806008  00000d4e  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00000d4e  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  00000d80  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000168  00000000  00000000  00000dbc  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00004bef  00000000  00000000  00000f24  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00003722  00000000  00000000  00005b13  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   000011de  00000000  00000000  00009235  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000304  00000000  00000000  0000a414  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00001b2b  00000000  00000000  0000a718  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000008da  00000000  00000000  0000c243  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000108  00000000  00000000  0000cb1d  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 7a 00 	jmp	0xf4	; 0xf4 <__ctors_end>
   4:	0c 94 97 00 	jmp	0x12e	; 0x12e <__bad_interrupt>
   8:	0c 94 97 00 	jmp	0x12e	; 0x12e <__bad_interrupt>
   c:	0c 94 97 00 	jmp	0x12e	; 0x12e <__bad_interrupt>
  10:	0c 94 97 00 	jmp	0x12e	; 0x12e <__bad_interrupt>
  14:	0c 94 97 00 	jmp	0x12e	; 0x12e <__bad_interrupt>
  18:	0c 94 97 00 	jmp	0x12e	; 0x12e <__bad_interrupt>
  1c:	0c 94 97 00 	jmp	0x12e	; 0x12e <__bad_interrupt>
  20:	0c 94 97 00 	jmp	0x12e	; 0x12e <__bad_interrupt>
  24:	0c 94 97 00 	jmp	0x12e	; 0x12e <__bad_interrupt>
  28:	0c 94 97 00 	jmp	0x12e	; 0x12e <__bad_interrupt>
  2c:	0c 94 97 00 	jmp	0x12e	; 0x12e <__bad_interrupt>
  30:	0c 94 97 00 	jmp	0x12e	; 0x12e <__bad_interrupt>
  34:	0c 94 97 00 	jmp	0x12e	; 0x12e <__bad_interrupt>
  38:	0c 94 97 00 	jmp	0x12e	; 0x12e <__bad_interrupt>
  3c:	0c 94 97 00 	jmp	0x12e	; 0x12e <__bad_interrupt>
  40:	0c 94 97 00 	jmp	0x12e	; 0x12e <__bad_interrupt>
  44:	0c 94 97 00 	jmp	0x12e	; 0x12e <__bad_interrupt>
  48:	0c 94 97 00 	jmp	0x12e	; 0x12e <__bad_interrupt>
  4c:	0c 94 97 00 	jmp	0x12e	; 0x12e <__bad_interrupt>
  50:	0c 94 97 00 	jmp	0x12e	; 0x12e <__bad_interrupt>
  54:	0c 94 97 00 	jmp	0x12e	; 0x12e <__bad_interrupt>
  58:	0c 94 97 00 	jmp	0x12e	; 0x12e <__bad_interrupt>
  5c:	0c 94 97 00 	jmp	0x12e	; 0x12e <__bad_interrupt>
  60:	0c 94 97 00 	jmp	0x12e	; 0x12e <__bad_interrupt>
  64:	0c 94 97 00 	jmp	0x12e	; 0x12e <__bad_interrupt>
  68:	0c 94 97 00 	jmp	0x12e	; 0x12e <__bad_interrupt>
  6c:	0c 94 97 00 	jmp	0x12e	; 0x12e <__bad_interrupt>
  70:	0c 94 97 00 	jmp	0x12e	; 0x12e <__bad_interrupt>
  74:	0c 94 97 00 	jmp	0x12e	; 0x12e <__bad_interrupt>
  78:	0c 94 97 00 	jmp	0x12e	; 0x12e <__bad_interrupt>
  7c:	0c 94 97 00 	jmp	0x12e	; 0x12e <__bad_interrupt>
  80:	0c 94 97 00 	jmp	0x12e	; 0x12e <__bad_interrupt>
  84:	0c 94 97 00 	jmp	0x12e	; 0x12e <__bad_interrupt>
  88:	0c 94 97 00 	jmp	0x12e	; 0x12e <__bad_interrupt>
  8c:	0c 94 97 00 	jmp	0x12e	; 0x12e <__bad_interrupt>
  90:	0c 94 97 00 	jmp	0x12e	; 0x12e <__bad_interrupt>
  94:	0c 94 97 00 	jmp	0x12e	; 0x12e <__bad_interrupt>
  98:	0c 94 97 00 	jmp	0x12e	; 0x12e <__bad_interrupt>
  9c:	0c 94 97 00 	jmp	0x12e	; 0x12e <__bad_interrupt>
  a0:	0c 94 97 00 	jmp	0x12e	; 0x12e <__bad_interrupt>
  a4:	0c 94 97 00 	jmp	0x12e	; 0x12e <__bad_interrupt>
  a8:	0c 94 97 00 	jmp	0x12e	; 0x12e <__bad_interrupt>
  ac:	0c 94 97 00 	jmp	0x12e	; 0x12e <__bad_interrupt>
  b0:	0c 94 97 00 	jmp	0x12e	; 0x12e <__bad_interrupt>
  b4:	0c 94 97 00 	jmp	0x12e	; 0x12e <__bad_interrupt>
  b8:	0c 94 97 00 	jmp	0x12e	; 0x12e <__bad_interrupt>
  bc:	0c 94 97 00 	jmp	0x12e	; 0x12e <__bad_interrupt>
  c0:	0c 94 97 00 	jmp	0x12e	; 0x12e <__bad_interrupt>
  c4:	0c 94 97 00 	jmp	0x12e	; 0x12e <__bad_interrupt>
  c8:	0c 94 97 00 	jmp	0x12e	; 0x12e <__bad_interrupt>
  cc:	0c 94 97 00 	jmp	0x12e	; 0x12e <__bad_interrupt>
  d0:	0c 94 97 00 	jmp	0x12e	; 0x12e <__bad_interrupt>
  d4:	0c 94 97 00 	jmp	0x12e	; 0x12e <__bad_interrupt>
  d8:	0c 94 97 00 	jmp	0x12e	; 0x12e <__bad_interrupt>
  dc:	0c 94 97 00 	jmp	0x12e	; 0x12e <__bad_interrupt>
  e0:	0c 94 97 00 	jmp	0x12e	; 0x12e <__bad_interrupt>
  e4:	0c 94 97 00 	jmp	0x12e	; 0x12e <__bad_interrupt>
  e8:	0c 94 97 00 	jmp	0x12e	; 0x12e <__bad_interrupt>
  ec:	0c 94 97 00 	jmp	0x12e	; 0x12e <__bad_interrupt>
  f0:	0c 94 97 00 	jmp	0x12e	; 0x12e <__bad_interrupt>

000000f4 <__ctors_end>:
  f4:	11 24       	eor	r1, r1
  f6:	1f be       	out	0x3f, r1	; 63
  f8:	cf ef       	ldi	r28, 0xFF	; 255
  fa:	cd bf       	out	0x3d, r28	; 61
  fc:	df e7       	ldi	r29, 0x7F	; 127
  fe:	de bf       	out	0x3e, r29	; 62

00000100 <__do_copy_data>:
 100:	10 e6       	ldi	r17, 0x60	; 96
 102:	a0 e0       	ldi	r26, 0x00	; 0
 104:	b0 e6       	ldi	r27, 0x60	; 96
 106:	e2 eb       	ldi	r30, 0xB2	; 178
 108:	fc e0       	ldi	r31, 0x0C	; 12
 10a:	02 c0       	rjmp	.+4      	; 0x110 <__do_copy_data+0x10>
 10c:	05 90       	lpm	r0, Z+
 10e:	0d 92       	st	X+, r0
 110:	a8 30       	cpi	r26, 0x08	; 8
 112:	b1 07       	cpc	r27, r17
 114:	d9 f7       	brne	.-10     	; 0x10c <__do_copy_data+0xc>

00000116 <__do_clear_bss>:
 116:	20 e6       	ldi	r18, 0x60	; 96
 118:	a8 e0       	ldi	r26, 0x08	; 8
 11a:	b0 e6       	ldi	r27, 0x60	; 96
 11c:	01 c0       	rjmp	.+2      	; 0x120 <.do_clear_bss_start>

0000011e <.do_clear_bss_loop>:
 11e:	1d 92       	st	X+, r1

00000120 <.do_clear_bss_start>:
 120:	a6 3c       	cpi	r26, 0xC6	; 198
 122:	b2 07       	cpc	r27, r18
 124:	e1 f7       	brne	.-8      	; 0x11e <.do_clear_bss_loop>
 126:	0e 94 dd 02 	call	0x5ba	; 0x5ba <main>
 12a:	0c 94 57 06 	jmp	0xcae	; 0xcae <_exit>

0000012e <__bad_interrupt>:
 12e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000132 <initializeAVR>:


void initializeAVR(){
	
	//Disable the Clock prescaler
	CLKCTRL_MCLKCTRLA = 0x00;
 132:	10 92 60 00 	sts	0x0060, r1	; 0x800060 <__TEXT_REGION_LENGTH__+0x7f0060>
	//Set the Clock prescaler register to 0 (no division)
	CLKCTRL_MCLKCTRLB = 0x00;
 136:	10 92 61 00 	sts	0x0061, r1	; 0x800061 <__TEXT_REGION_LENGTH__+0x7f0061>
	//Disable Configuration Change Protection
	CCP = 0xD8;
 13a:	88 ed       	ldi	r24, 0xD8	; 216
 13c:	84 bf       	out	0x34, r24	; 52
	//Set the Internal Oscillator to 24MHz
	CLKCTRL_OSCHFCTRLA = 0x26; 
 13e:	86 e2       	ldi	r24, 0x26	; 38
 140:	80 93 68 00 	sts	0x0068, r24	; 0x800068 <__TEXT_REGION_LENGTH__+0x7f0068>
	
	
	LED0 = (GPIO) {0b00000001, (volatile u8 *) &PORTA};
 144:	ac eb       	ldi	r26, 0xBC	; 188
 146:	b0 e6       	ldi	r27, 0x60	; 96
 148:	e1 e0       	ldi	r30, 0x01	; 1
 14a:	ec 93       	st	X, r30
 14c:	80 e0       	ldi	r24, 0x00	; 0
 14e:	94 e0       	ldi	r25, 0x04	; 4
 150:	11 96       	adiw	r26, 0x01	; 1
 152:	8d 93       	st	X+, r24
 154:	9c 93       	st	X, r25
 156:	12 97       	sbiw	r26, 0x02	; 2
	LED1 = (GPIO) {0b00000010, (volatile u8 *) &PORTA};
 158:	a3 e5       	ldi	r26, 0x53	; 83
 15a:	b0 e6       	ldi	r27, 0x60	; 96
 15c:	72 e0       	ldi	r23, 0x02	; 2
 15e:	7c 93       	st	X, r23
 160:	11 96       	adiw	r26, 0x01	; 1
 162:	8d 93       	st	X+, r24
 164:	9c 93       	st	X, r25
 166:	12 97       	sbiw	r26, 0x02	; 2
	LED2 = (GPIO) {0b00000100, (volatile u8 *) &PORTA};
 168:	ab e9       	ldi	r26, 0x9B	; 155
 16a:	b0 e6       	ldi	r27, 0x60	; 96
 16c:	64 e0       	ldi	r22, 0x04	; 4
 16e:	6c 93       	st	X, r22
 170:	11 96       	adiw	r26, 0x01	; 1
 172:	8d 93       	st	X+, r24
 174:	9c 93       	st	X, r25
 176:	12 97       	sbiw	r26, 0x02	; 2
	LED3 = (GPIO) {0b00001000, (volatile u8 *) &PORTA};
 178:	a0 e8       	ldi	r26, 0x80	; 128
 17a:	b0 e6       	ldi	r27, 0x60	; 96
 17c:	38 e0       	ldi	r19, 0x08	; 8
 17e:	3c 93       	st	X, r19
 180:	11 96       	adiw	r26, 0x01	; 1
 182:	8d 93       	st	X+, r24
 184:	9c 93       	st	X, r25
 186:	12 97       	sbiw	r26, 0x02	; 2
	LED4 = (GPIO) {0b00010000, (volatile u8 *) &PORTA};
 188:	a6 eb       	ldi	r26, 0xB6	; 182
 18a:	b0 e6       	ldi	r27, 0x60	; 96
 18c:	20 e1       	ldi	r18, 0x10	; 16
 18e:	2c 93       	st	X, r18
 190:	11 96       	adiw	r26, 0x01	; 1
 192:	8d 93       	st	X+, r24
 194:	9c 93       	st	X, r25
 196:	12 97       	sbiw	r26, 0x02	; 2
	LED5 = (GPIO) {0b00100000, (volatile u8 *) &PORTA};
 198:	aa ea       	ldi	r26, 0xAA	; 170
 19a:	b0 e6       	ldi	r27, 0x60	; 96
 19c:	50 e2       	ldi	r21, 0x20	; 32
 19e:	5c 93       	st	X, r21
 1a0:	11 96       	adiw	r26, 0x01	; 1
 1a2:	8d 93       	st	X+, r24
 1a4:	9c 93       	st	X, r25
 1a6:	12 97       	sbiw	r26, 0x02	; 2
	LED6 = (GPIO) {0b01000000, (volatile u8 *) &PORTA};
 1a8:	a7 e4       	ldi	r26, 0x47	; 71
 1aa:	b0 e6       	ldi	r27, 0x60	; 96
 1ac:	40 e4       	ldi	r20, 0x40	; 64
 1ae:	4c 93       	st	X, r20
 1b0:	11 96       	adiw	r26, 0x01	; 1
 1b2:	8d 93       	st	X+, r24
 1b4:	9c 93       	st	X, r25
 1b6:	12 97       	sbiw	r26, 0x02	; 2
	LED7 = (GPIO) {0b10000000, (volatile u8 *) &PORTA};
 1b8:	a2 e9       	ldi	r26, 0x92	; 146
 1ba:	b0 e6       	ldi	r27, 0x60	; 96
 1bc:	f0 e8       	ldi	r31, 0x80	; 128
 1be:	fc 93       	st	X, r31
 1c0:	11 96       	adiw	r26, 0x01	; 1
 1c2:	8d 93       	st	X+, r24
 1c4:	9c 93       	st	X, r25
 1c6:	12 97       	sbiw	r26, 0x02	; 2
		
	RFM_RST = (GPIO) {0b00010000, (volatile u8 *) &PORTB};
 1c8:	a6 e8       	ldi	r26, 0x86	; 134
 1ca:	b0 e6       	ldi	r27, 0x60	; 96
 1cc:	2c 93       	st	X, r18
 1ce:	80 e2       	ldi	r24, 0x20	; 32
 1d0:	94 e0       	ldi	r25, 0x04	; 4
 1d2:	11 96       	adiw	r26, 0x01	; 1
 1d4:	8d 93       	st	X+, r24
 1d6:	9c 93       	st	X, r25
 1d8:	12 97       	sbiw	r26, 0x02	; 2
		
	GPIO0 = (GPIO) {0b00000001, (volatile u8 *) &PORTC};
 1da:	a9 e8       	ldi	r26, 0x89	; 137
 1dc:	b0 e6       	ldi	r27, 0x60	; 96
 1de:	ec 93       	st	X, r30
 1e0:	80 e4       	ldi	r24, 0x40	; 64
 1e2:	94 e0       	ldi	r25, 0x04	; 4
 1e4:	11 96       	adiw	r26, 0x01	; 1
 1e6:	8d 93       	st	X+, r24
 1e8:	9c 93       	st	X, r25
 1ea:	12 97       	sbiw	r26, 0x02	; 2
	GPIO1 = (GPIO) {0b00000010, (volatile u8 *) &PORTC};
 1ec:	a4 e4       	ldi	r26, 0x44	; 68
 1ee:	b0 e6       	ldi	r27, 0x60	; 96
 1f0:	7c 93       	st	X, r23
 1f2:	11 96       	adiw	r26, 0x01	; 1
 1f4:	8d 93       	st	X+, r24
 1f6:	9c 93       	st	X, r25
 1f8:	12 97       	sbiw	r26, 0x02	; 2
	GPIO2 = (GPIO) {0b00000100, (volatile u8 *) &PORTC};
 1fa:	a0 eb       	ldi	r26, 0xB0	; 176
 1fc:	b0 e6       	ldi	r27, 0x60	; 96
 1fe:	6c 93       	st	X, r22
 200:	11 96       	adiw	r26, 0x01	; 1
 202:	8d 93       	st	X+, r24
 204:	9c 93       	st	X, r25
 206:	12 97       	sbiw	r26, 0x02	; 2
	GPIO3 = (GPIO) {0b00001000, (volatile u8 *) &PORTC};
 208:	a0 e5       	ldi	r26, 0x50	; 80
 20a:	b0 e6       	ldi	r27, 0x60	; 96
 20c:	3c 93       	st	X, r19
 20e:	11 96       	adiw	r26, 0x01	; 1
 210:	8d 93       	st	X+, r24
 212:	9c 93       	st	X, r25
 214:	12 97       	sbiw	r26, 0x02	; 2
	GPIO4 = (GPIO) {0b00010000, (volatile u8 *) &PORTC};
 216:	ab e0       	ldi	r26, 0x0B	; 11
 218:	b0 e6       	ldi	r27, 0x60	; 96
 21a:	2c 93       	st	X, r18
 21c:	11 96       	adiw	r26, 0x01	; 1
 21e:	8d 93       	st	X+, r24
 220:	9c 93       	st	X, r25
 222:	12 97       	sbiw	r26, 0x02	; 2
	GPIO5 = (GPIO) {0b00100000, (volatile u8 *) &PORTC};
 224:	af eb       	ldi	r26, 0xBF	; 191
 226:	b0 e6       	ldi	r27, 0x60	; 96
 228:	5c 93       	st	X, r21
 22a:	11 96       	adiw	r26, 0x01	; 1
 22c:	8d 93       	st	X+, r24
 22e:	9c 93       	st	X, r25
 230:	12 97       	sbiw	r26, 0x02	; 2
	GPIO6 = (GPIO) {0b01000000, (volatile u8 *) &PORTC};
 232:	a5 e9       	ldi	r26, 0x95	; 149
 234:	b0 e6       	ldi	r27, 0x60	; 96
 236:	4c 93       	st	X, r20
 238:	11 96       	adiw	r26, 0x01	; 1
 23a:	8d 93       	st	X+, r24
 23c:	9c 93       	st	X, r25
 23e:	12 97       	sbiw	r26, 0x02	; 2
	GPIO7 = (GPIO) {0b10000000, (volatile u8 *) &PORTC};
 240:	a3 eb       	ldi	r26, 0xB3	; 179
 242:	b0 e6       	ldi	r27, 0x60	; 96
 244:	fc 93       	st	X, r31
 246:	11 96       	adiw	r26, 0x01	; 1
 248:	8d 93       	st	X+, r24
 24a:	9c 93       	st	X, r25
 24c:	12 97       	sbiw	r26, 0x02	; 2
		
	GPIO8 = (GPIO) {0b00000001, (volatile u8 *) &PORTD};
 24e:	a9 eb       	ldi	r26, 0xB9	; 185
 250:	b0 e6       	ldi	r27, 0x60	; 96
 252:	ec 93       	st	X, r30
 254:	80 e6       	ldi	r24, 0x60	; 96
 256:	94 e0       	ldi	r25, 0x04	; 4
 258:	11 96       	adiw	r26, 0x01	; 1
 25a:	8d 93       	st	X+, r24
 25c:	9c 93       	st	X, r25
 25e:	12 97       	sbiw	r26, 0x02	; 2
	GPIO9 = (GPIO) {0b00000010, (volatile u8 *) &PORTD};
 260:	ae e9       	ldi	r26, 0x9E	; 158
 262:	b0 e6       	ldi	r27, 0x60	; 96
 264:	7c 93       	st	X, r23
 266:	11 96       	adiw	r26, 0x01	; 1
 268:	8d 93       	st	X+, r24
 26a:	9c 93       	st	X, r25
 26c:	12 97       	sbiw	r26, 0x02	; 2
	GPIO10 = (GPIO) {0b00000100, (volatile u8 *) &PORTD};
 26e:	a7 ea       	ldi	r26, 0xA7	; 167
 270:	b0 e6       	ldi	r27, 0x60	; 96
 272:	6c 93       	st	X, r22
 274:	11 96       	adiw	r26, 0x01	; 1
 276:	8d 93       	st	X+, r24
 278:	9c 93       	st	X, r25
 27a:	12 97       	sbiw	r26, 0x02	; 2
	GPIO11 = (GPIO) {0b00001000, (volatile u8 *) &PORTD};
 27c:	a3 e8       	ldi	r26, 0x83	; 131
 27e:	b0 e6       	ldi	r27, 0x60	; 96
 280:	3c 93       	st	X, r19
 282:	11 96       	adiw	r26, 0x01	; 1
 284:	8d 93       	st	X+, r24
 286:	9c 93       	st	X, r25
 288:	12 97       	sbiw	r26, 0x02	; 2
	GPIO12 = (GPIO) {0b00010000, (volatile u8 *) &PORTD};
 28a:	a1 e4       	ldi	r26, 0x41	; 65
 28c:	b0 e6       	ldi	r27, 0x60	; 96
 28e:	2c 93       	st	X, r18
 290:	11 96       	adiw	r26, 0x01	; 1
 292:	8d 93       	st	X+, r24
 294:	9c 93       	st	X, r25
 296:	12 97       	sbiw	r26, 0x02	; 2
	GPIO13 = (GPIO) {0b00100000, (volatile u8 *) &PORTD};
 298:	a8 e9       	ldi	r26, 0x98	; 152
 29a:	b0 e6       	ldi	r27, 0x60	; 96
 29c:	5c 93       	st	X, r21
 29e:	11 96       	adiw	r26, 0x01	; 1
 2a0:	8d 93       	st	X+, r24
 2a2:	9c 93       	st	X, r25
 2a4:	12 97       	sbiw	r26, 0x02	; 2
	GPIO14 = (GPIO) {0b01000000, (volatile u8 *) &PORTD};
 2a6:	a8 e0       	ldi	r26, 0x08	; 8
 2a8:	b0 e6       	ldi	r27, 0x60	; 96
 2aa:	4c 93       	st	X, r20
 2ac:	11 96       	adiw	r26, 0x01	; 1
 2ae:	8d 93       	st	X+, r24
 2b0:	9c 93       	st	X, r25
 2b2:	12 97       	sbiw	r26, 0x02	; 2
	GPIO15 = (GPIO) {0b10000000, (volatile u8 *) &PORTD};
 2b4:	a4 ea       	ldi	r26, 0xA4	; 164
 2b6:	b0 e6       	ldi	r27, 0x60	; 96
 2b8:	fc 93       	st	X, r31
 2ba:	11 96       	adiw	r26, 0x01	; 1
 2bc:	8d 93       	st	X+, r24
 2be:	9c 93       	st	X, r25
 2c0:	12 97       	sbiw	r26, 0x02	; 2
	
	RFM_SS = (GPIO) {0b00001000, (volatile u8 *) &PORTE};
 2c2:	a1 ea       	ldi	r26, 0xA1	; 161
 2c4:	b0 e6       	ldi	r27, 0x60	; 96
 2c6:	3c 93       	st	X, r19
 2c8:	80 e8       	ldi	r24, 0x80	; 128
 2ca:	94 e0       	ldi	r25, 0x04	; 4
 2cc:	11 96       	adiw	r26, 0x01	; 1
 2ce:	8d 93       	st	X+, r24
 2d0:	9c 93       	st	X, r25
 2d2:	12 97       	sbiw	r26, 0x02	; 2
		
	DIO0 = (GPIO) {0b00000001, (volatile u8 *) &PORTF};
 2d4:	aa e4       	ldi	r26, 0x4A	; 74
 2d6:	b0 e6       	ldi	r27, 0x60	; 96
 2d8:	ec 93       	st	X, r30
 2da:	80 ea       	ldi	r24, 0xA0	; 160
 2dc:	94 e0       	ldi	r25, 0x04	; 4
 2de:	11 96       	adiw	r26, 0x01	; 1
 2e0:	8d 93       	st	X+, r24
 2e2:	9c 93       	st	X, r25
 2e4:	12 97       	sbiw	r26, 0x02	; 2
	DIO1 = (GPIO) {0b00000010, (volatile u8 *) &PORTF};
 2e6:	ec e8       	ldi	r30, 0x8C	; 140
 2e8:	f0 e6       	ldi	r31, 0x60	; 96
 2ea:	70 83       	st	Z, r23
 2ec:	81 83       	std	Z+1, r24	; 0x01
 2ee:	92 83       	std	Z+2, r25	; 0x02
	DIO2 = (GPIO) {0b00000100, (volatile u8 *) &PORTF};
 2f0:	ef e8       	ldi	r30, 0x8F	; 143
 2f2:	f0 e6       	ldi	r31, 0x60	; 96
 2f4:	60 83       	st	Z, r22
 2f6:	81 83       	std	Z+1, r24	; 0x01
 2f8:	92 83       	std	Z+2, r25	; 0x02
	DIO3 = (GPIO) {0b00001000, (volatile u8 *) &PORTF};
 2fa:	e2 ec       	ldi	r30, 0xC2	; 194
 2fc:	f0 e6       	ldi	r31, 0x60	; 96
 2fe:	30 83       	st	Z, r19
 300:	81 83       	std	Z+1, r24	; 0x01
 302:	92 83       	std	Z+2, r25	; 0x02
	DIO4 = (GPIO) {0b00010000, (volatile u8 *) &PORTF};
 304:	ed ea       	ldi	r30, 0xAD	; 173
 306:	f0 e6       	ldi	r31, 0x60	; 96
 308:	20 83       	st	Z, r18
 30a:	81 83       	std	Z+1, r24	; 0x01
 30c:	92 83       	std	Z+2, r25	; 0x02
	DIO5 = (GPIO) {0b00100000, (volatile u8 *) &PORTF};
 30e:	ed e4       	ldi	r30, 0x4D	; 77
 310:	f0 e6       	ldi	r31, 0x60	; 96
 312:	50 83       	st	Z, r21
 314:	81 83       	std	Z+1, r24	; 0x01
 316:	92 83       	std	Z+2, r25	; 0x02
		
	RESET = (GPIO) {0b01000000, (volatile u8 *) &PORTF};
 318:	ee e0       	ldi	r30, 0x0E	; 14
 31a:	f0 e6       	ldi	r31, 0x60	; 96
 31c:	40 83       	st	Z, r20
 31e:	81 83       	std	Z+1, r24	; 0x01
 320:	92 83       	std	Z+2, r25	; 0x02
		
		
	LEDs[0] = LED0;
 322:	e6 e5       	ldi	r30, 0x56	; 86
 324:	f0 e6       	ldi	r31, 0x60	; 96
 326:	80 91 bc 60 	lds	r24, 0x60BC	; 0x8060bc <LED0>
 32a:	90 91 bd 60 	lds	r25, 0x60BD	; 0x8060bd <LED0+0x1>
 32e:	a0 91 be 60 	lds	r26, 0x60BE	; 0x8060be <LED0+0x2>
 332:	80 83       	st	Z, r24
 334:	91 83       	std	Z+1, r25	; 0x01
 336:	a2 83       	std	Z+2, r26	; 0x02
	LEDs[1] = LED1;
 338:	80 91 53 60 	lds	r24, 0x6053	; 0x806053 <LED1>
 33c:	90 91 54 60 	lds	r25, 0x6054	; 0x806054 <LED1+0x1>
 340:	a0 91 55 60 	lds	r26, 0x6055	; 0x806055 <LED1+0x2>
 344:	83 83       	std	Z+3, r24	; 0x03
 346:	94 83       	std	Z+4, r25	; 0x04
 348:	a5 83       	std	Z+5, r26	; 0x05
	LEDs[2] = LED2;
 34a:	80 91 9b 60 	lds	r24, 0x609B	; 0x80609b <LED2>
 34e:	90 91 9c 60 	lds	r25, 0x609C	; 0x80609c <LED2+0x1>
 352:	a0 91 9d 60 	lds	r26, 0x609D	; 0x80609d <LED2+0x2>
 356:	86 83       	std	Z+6, r24	; 0x06
 358:	97 83       	std	Z+7, r25	; 0x07
 35a:	a0 87       	std	Z+8, r26	; 0x08
	LEDs[3] = LED3;
 35c:	80 91 80 60 	lds	r24, 0x6080	; 0x806080 <LED3>
 360:	90 91 81 60 	lds	r25, 0x6081	; 0x806081 <LED3+0x1>
 364:	a0 91 82 60 	lds	r26, 0x6082	; 0x806082 <LED3+0x2>
 368:	81 87       	std	Z+9, r24	; 0x09
 36a:	92 87       	std	Z+10, r25	; 0x0a
 36c:	a3 87       	std	Z+11, r26	; 0x0b
	LEDs[4] = LED4;
 36e:	80 91 b6 60 	lds	r24, 0x60B6	; 0x8060b6 <LED4>
 372:	90 91 b7 60 	lds	r25, 0x60B7	; 0x8060b7 <LED4+0x1>
 376:	a0 91 b8 60 	lds	r26, 0x60B8	; 0x8060b8 <LED4+0x2>
 37a:	84 87       	std	Z+12, r24	; 0x0c
 37c:	95 87       	std	Z+13, r25	; 0x0d
 37e:	a6 87       	std	Z+14, r26	; 0x0e
	LEDs[5] = LED5;
 380:	80 91 aa 60 	lds	r24, 0x60AA	; 0x8060aa <LED5>
 384:	90 91 ab 60 	lds	r25, 0x60AB	; 0x8060ab <LED5+0x1>
 388:	a0 91 ac 60 	lds	r26, 0x60AC	; 0x8060ac <LED5+0x2>
 38c:	87 87       	std	Z+15, r24	; 0x0f
 38e:	90 8b       	std	Z+16, r25	; 0x10
 390:	a1 8b       	std	Z+17, r26	; 0x11
	LEDs[6] = LED6;
 392:	80 91 47 60 	lds	r24, 0x6047	; 0x806047 <LED6>
 396:	90 91 48 60 	lds	r25, 0x6048	; 0x806048 <LED6+0x1>
 39a:	a0 91 49 60 	lds	r26, 0x6049	; 0x806049 <LED6+0x2>
 39e:	82 8b       	std	Z+18, r24	; 0x12
 3a0:	93 8b       	std	Z+19, r25	; 0x13
 3a2:	a4 8b       	std	Z+20, r26	; 0x14
	LEDs[7] = LED7;
 3a4:	80 91 92 60 	lds	r24, 0x6092	; 0x806092 <LED7>
 3a8:	90 91 93 60 	lds	r25, 0x6093	; 0x806093 <LED7+0x1>
 3ac:	a0 91 94 60 	lds	r26, 0x6094	; 0x806094 <LED7+0x2>
 3b0:	85 8b       	std	Z+21, r24	; 0x15
 3b2:	96 8b       	std	Z+22, r25	; 0x16
 3b4:	a7 8b       	std	Z+23, r26	; 0x17
	
	GPIOs[0] = GPIO0;
 3b6:	e1 e1       	ldi	r30, 0x11	; 17
 3b8:	f0 e6       	ldi	r31, 0x60	; 96
 3ba:	80 91 89 60 	lds	r24, 0x6089	; 0x806089 <GPIO0>
 3be:	90 91 8a 60 	lds	r25, 0x608A	; 0x80608a <GPIO0+0x1>
 3c2:	a0 91 8b 60 	lds	r26, 0x608B	; 0x80608b <GPIO0+0x2>
 3c6:	80 83       	st	Z, r24
 3c8:	91 83       	std	Z+1, r25	; 0x01
 3ca:	a2 83       	std	Z+2, r26	; 0x02
	GPIOs[1] = GPIO1;
 3cc:	80 91 44 60 	lds	r24, 0x6044	; 0x806044 <GPIO1>
 3d0:	90 91 45 60 	lds	r25, 0x6045	; 0x806045 <GPIO1+0x1>
 3d4:	a0 91 46 60 	lds	r26, 0x6046	; 0x806046 <GPIO1+0x2>
 3d8:	83 83       	std	Z+3, r24	; 0x03
 3da:	94 83       	std	Z+4, r25	; 0x04
 3dc:	a5 83       	std	Z+5, r26	; 0x05
	GPIOs[2] = GPIO2;
 3de:	80 91 b0 60 	lds	r24, 0x60B0	; 0x8060b0 <GPIO2>
 3e2:	90 91 b1 60 	lds	r25, 0x60B1	; 0x8060b1 <GPIO2+0x1>
 3e6:	a0 91 b2 60 	lds	r26, 0x60B2	; 0x8060b2 <GPIO2+0x2>
 3ea:	86 83       	std	Z+6, r24	; 0x06
 3ec:	97 83       	std	Z+7, r25	; 0x07
 3ee:	a0 87       	std	Z+8, r26	; 0x08
	GPIOs[3] = GPIO3;
 3f0:	80 91 50 60 	lds	r24, 0x6050	; 0x806050 <GPIO3>
 3f4:	90 91 51 60 	lds	r25, 0x6051	; 0x806051 <GPIO3+0x1>
 3f8:	a0 91 52 60 	lds	r26, 0x6052	; 0x806052 <GPIO3+0x2>
 3fc:	81 87       	std	Z+9, r24	; 0x09
 3fe:	92 87       	std	Z+10, r25	; 0x0a
 400:	a3 87       	std	Z+11, r26	; 0x0b
	GPIOs[4] = GPIO4;
 402:	80 91 0b 60 	lds	r24, 0x600B	; 0x80600b <GPIO4>
 406:	90 91 0c 60 	lds	r25, 0x600C	; 0x80600c <GPIO4+0x1>
 40a:	a0 91 0d 60 	lds	r26, 0x600D	; 0x80600d <GPIO4+0x2>
 40e:	84 87       	std	Z+12, r24	; 0x0c
 410:	95 87       	std	Z+13, r25	; 0x0d
 412:	a6 87       	std	Z+14, r26	; 0x0e
	GPIOs[5] = GPIO5;
 414:	80 91 bf 60 	lds	r24, 0x60BF	; 0x8060bf <GPIO5>
 418:	90 91 c0 60 	lds	r25, 0x60C0	; 0x8060c0 <GPIO5+0x1>
 41c:	a0 91 c1 60 	lds	r26, 0x60C1	; 0x8060c1 <GPIO5+0x2>
 420:	87 87       	std	Z+15, r24	; 0x0f
 422:	90 8b       	std	Z+16, r25	; 0x10
 424:	a1 8b       	std	Z+17, r26	; 0x11
	GPIOs[6] = GPIO6;
 426:	80 91 95 60 	lds	r24, 0x6095	; 0x806095 <GPIO6>
 42a:	90 91 96 60 	lds	r25, 0x6096	; 0x806096 <GPIO6+0x1>
 42e:	a0 91 97 60 	lds	r26, 0x6097	; 0x806097 <GPIO6+0x2>
 432:	82 8b       	std	Z+18, r24	; 0x12
 434:	93 8b       	std	Z+19, r25	; 0x13
 436:	a4 8b       	std	Z+20, r26	; 0x14
	GPIOs[7] = GPIO7;
 438:	80 91 b3 60 	lds	r24, 0x60B3	; 0x8060b3 <GPIO7>
 43c:	90 91 b4 60 	lds	r25, 0x60B4	; 0x8060b4 <GPIO7+0x1>
 440:	a0 91 b5 60 	lds	r26, 0x60B5	; 0x8060b5 <GPIO7+0x2>
 444:	85 8b       	std	Z+21, r24	; 0x15
 446:	96 8b       	std	Z+22, r25	; 0x16
 448:	a7 8b       	std	Z+23, r26	; 0x17
	
	GPIOs[8] = GPIO8;
 44a:	80 91 b9 60 	lds	r24, 0x60B9	; 0x8060b9 <GPIO8>
 44e:	90 91 ba 60 	lds	r25, 0x60BA	; 0x8060ba <GPIO8+0x1>
 452:	a0 91 bb 60 	lds	r26, 0x60BB	; 0x8060bb <GPIO8+0x2>
 456:	80 8f       	std	Z+24, r24	; 0x18
 458:	91 8f       	std	Z+25, r25	; 0x19
 45a:	a2 8f       	std	Z+26, r26	; 0x1a
	GPIOs[9] = GPIO9;
 45c:	80 91 9e 60 	lds	r24, 0x609E	; 0x80609e <GPIO9>
 460:	90 91 9f 60 	lds	r25, 0x609F	; 0x80609f <GPIO9+0x1>
 464:	a0 91 a0 60 	lds	r26, 0x60A0	; 0x8060a0 <GPIO9+0x2>
 468:	83 8f       	std	Z+27, r24	; 0x1b
 46a:	94 8f       	std	Z+28, r25	; 0x1c
 46c:	a5 8f       	std	Z+29, r26	; 0x1d
	GPIOs[10] = GPIO10;
 46e:	80 91 a7 60 	lds	r24, 0x60A7	; 0x8060a7 <GPIO10>
 472:	90 91 a8 60 	lds	r25, 0x60A8	; 0x8060a8 <GPIO10+0x1>
 476:	a0 91 a9 60 	lds	r26, 0x60A9	; 0x8060a9 <GPIO10+0x2>
 47a:	86 8f       	std	Z+30, r24	; 0x1e
 47c:	97 8f       	std	Z+31, r25	; 0x1f
 47e:	a0 a3       	std	Z+32, r26	; 0x20
	GPIOs[11] = GPIO11;
 480:	80 91 83 60 	lds	r24, 0x6083	; 0x806083 <GPIO11>
 484:	90 91 84 60 	lds	r25, 0x6084	; 0x806084 <GPIO11+0x1>
 488:	a0 91 85 60 	lds	r26, 0x6085	; 0x806085 <GPIO11+0x2>
 48c:	81 a3       	std	Z+33, r24	; 0x21
 48e:	92 a3       	std	Z+34, r25	; 0x22
 490:	a3 a3       	std	Z+35, r26	; 0x23
	GPIOs[12] = GPIO12;
 492:	80 91 41 60 	lds	r24, 0x6041	; 0x806041 <GPIO12>
 496:	90 91 42 60 	lds	r25, 0x6042	; 0x806042 <GPIO12+0x1>
 49a:	a0 91 43 60 	lds	r26, 0x6043	; 0x806043 <GPIO12+0x2>
 49e:	84 a3       	std	Z+36, r24	; 0x24
 4a0:	95 a3       	std	Z+37, r25	; 0x25
 4a2:	a6 a3       	std	Z+38, r26	; 0x26
	GPIOs[13] = GPIO13;
 4a4:	80 91 98 60 	lds	r24, 0x6098	; 0x806098 <GPIO13>
 4a8:	90 91 99 60 	lds	r25, 0x6099	; 0x806099 <GPIO13+0x1>
 4ac:	a0 91 9a 60 	lds	r26, 0x609A	; 0x80609a <GPIO13+0x2>
 4b0:	87 a3       	std	Z+39, r24	; 0x27
 4b2:	90 a7       	std	Z+40, r25	; 0x28
 4b4:	a1 a7       	std	Z+41, r26	; 0x29
	GPIOs[14] = GPIO14;
 4b6:	80 91 08 60 	lds	r24, 0x6008	; 0x806008 <__data_end>
 4ba:	90 91 09 60 	lds	r25, 0x6009	; 0x806009 <__data_end+0x1>
 4be:	a0 91 0a 60 	lds	r26, 0x600A	; 0x80600a <__data_end+0x2>
 4c2:	82 a7       	std	Z+42, r24	; 0x2a
 4c4:	93 a7       	std	Z+43, r25	; 0x2b
 4c6:	a4 a7       	std	Z+44, r26	; 0x2c
	GPIOs[15] = GPIO15;
 4c8:	80 91 a4 60 	lds	r24, 0x60A4	; 0x8060a4 <GPIO15>
 4cc:	90 91 a5 60 	lds	r25, 0x60A5	; 0x8060a5 <GPIO15+0x1>
 4d0:	a0 91 a6 60 	lds	r26, 0x60A6	; 0x8060a6 <GPIO15+0x2>
 4d4:	85 a7       	std	Z+45, r24	; 0x2d
 4d6:	96 a7       	std	Z+46, r25	; 0x2e
 4d8:	a7 a7       	std	Z+47, r26	; 0x2f
	
	DIOs[0] = DIO0;
 4da:	ee e6       	ldi	r30, 0x6E	; 110
 4dc:	f0 e6       	ldi	r31, 0x60	; 96
 4de:	80 91 4a 60 	lds	r24, 0x604A	; 0x80604a <DIO0>
 4e2:	90 91 4b 60 	lds	r25, 0x604B	; 0x80604b <DIO0+0x1>
 4e6:	a0 91 4c 60 	lds	r26, 0x604C	; 0x80604c <DIO0+0x2>
 4ea:	80 83       	st	Z, r24
 4ec:	91 83       	std	Z+1, r25	; 0x01
 4ee:	a2 83       	std	Z+2, r26	; 0x02
	DIOs[1] = DIO1;
 4f0:	80 91 8c 60 	lds	r24, 0x608C	; 0x80608c <DIO1>
 4f4:	90 91 8d 60 	lds	r25, 0x608D	; 0x80608d <DIO1+0x1>
 4f8:	a0 91 8e 60 	lds	r26, 0x608E	; 0x80608e <DIO1+0x2>
 4fc:	83 83       	std	Z+3, r24	; 0x03
 4fe:	94 83       	std	Z+4, r25	; 0x04
 500:	a5 83       	std	Z+5, r26	; 0x05
	DIOs[2] = DIO2;
 502:	80 91 8f 60 	lds	r24, 0x608F	; 0x80608f <DIO2>
 506:	90 91 90 60 	lds	r25, 0x6090	; 0x806090 <DIO2+0x1>
 50a:	a0 91 91 60 	lds	r26, 0x6091	; 0x806091 <DIO2+0x2>
 50e:	86 83       	std	Z+6, r24	; 0x06
 510:	97 83       	std	Z+7, r25	; 0x07
 512:	a0 87       	std	Z+8, r26	; 0x08
	DIOs[3] = DIO3;
 514:	80 91 c2 60 	lds	r24, 0x60C2	; 0x8060c2 <DIO3>
 518:	90 91 c3 60 	lds	r25, 0x60C3	; 0x8060c3 <DIO3+0x1>
 51c:	a0 91 c4 60 	lds	r26, 0x60C4	; 0x8060c4 <DIO3+0x2>
 520:	81 87       	std	Z+9, r24	; 0x09
 522:	92 87       	std	Z+10, r25	; 0x0a
 524:	a3 87       	std	Z+11, r26	; 0x0b
	DIOs[4] = DIO4;
 526:	80 91 ad 60 	lds	r24, 0x60AD	; 0x8060ad <DIO4>
 52a:	90 91 ae 60 	lds	r25, 0x60AE	; 0x8060ae <DIO4+0x1>
 52e:	a0 91 af 60 	lds	r26, 0x60AF	; 0x8060af <DIO4+0x2>
 532:	84 87       	std	Z+12, r24	; 0x0c
 534:	95 87       	std	Z+13, r25	; 0x0d
 536:	a6 87       	std	Z+14, r26	; 0x0e
	DIOs[5] = DIO5;
 538:	80 91 4d 60 	lds	r24, 0x604D	; 0x80604d <DIO5>
 53c:	90 91 4e 60 	lds	r25, 0x604E	; 0x80604e <DIO5+0x1>
 540:	a0 91 4f 60 	lds	r26, 0x604F	; 0x80604f <DIO5+0x2>
 544:	87 87       	std	Z+15, r24	; 0x0f
 546:	90 8b       	std	Z+16, r25	; 0x10
 548:	a1 8b       	std	Z+17, r26	; 0x11
 54a:	08 95       	ret

0000054c <digitalWrite>:
	digitalWrite(RFM_RST, 1);
}

void digitalWrite(GPIO pin, u8 value){

	if(value > 0){
 54c:	44 23       	and	r20, r20
 54e:	21 f0       	breq	.+8      	; 0x558 <digitalWrite+0xc>
		*(pin.port + OUTSET_OFFSET) = pin.pin; //OUTSET-Register
 550:	e7 2f       	mov	r30, r23
 552:	f8 2f       	mov	r31, r24
 554:	65 83       	std	Z+5, r22	; 0x05
 556:	08 95       	ret
	} else {
		*(pin.port + OUTCLR_OFFSET) = pin.pin; //OUTCLEAR-Register
 558:	e7 2f       	mov	r30, r23
 55a:	f8 2f       	mov	r31, r24
 55c:	66 83       	std	Z+6, r22	; 0x06
 55e:	08 95       	ret

00000560 <initializeGPIO>:

#include "GPIOFunctions.h"

void initializeGPIO(){
	//PORTA: LEDs
	PORTA_DIRSET = 0xFF; 
 560:	8f ef       	ldi	r24, 0xFF	; 255
 562:	80 93 01 04 	sts	0x0401, r24	; 0x800401 <__TEXT_REGION_LENGTH__+0x7f0401>
	
	//PORTB: UART, SPI, Reset of LoRa 
	PORTB_DIRSET = 0xFF; //FD 
 566:	80 93 21 04 	sts	0x0421, r24	; 0x800421 <__TEXT_REGION_LENGTH__+0x7f0421>
	
	//PORTC: GPIO Low Byte
	PORTC_DIRSET = 0xFF; 
 56a:	80 93 41 04 	sts	0x0441, r24	; 0x800441 <__TEXT_REGION_LENGTH__+0x7f0441>
	
	//PORTD: GPIO High Byte
	PORTD_DIRSET = 0xFF; 
 56e:	80 93 61 04 	sts	0x0461, r24	; 0x800461 <__TEXT_REGION_LENGTH__+0x7f0461>
	
	//PORTE: SPI Bus
	PORTE_DIRSET = 0x0D; 
 572:	8d e0       	ldi	r24, 0x0D	; 13
 574:	80 93 81 04 	sts	0x0481, r24	; 0x800481 <__TEXT_REGION_LENGTH__+0x7f0481>
	PORTE_PIN3CTRL = 0b00001000; //Set SS to have pullup
 578:	88 e0       	ldi	r24, 0x08	; 8
 57a:	80 93 93 04 	sts	0x0493, r24	; 0x800493 <__TEXT_REGION_LENGTH__+0x7f0493>
	PORTE_OUTSET = 0b00001000;  //Set SS to high
 57e:	80 93 85 04 	sts	0x0485, r24	; 0x800485 <__TEXT_REGION_LENGTH__+0x7f0485>
	
	//PORTF: DIOs (All Inputs)
	PORTF_DIRSET = 0x00;
 582:	10 92 a1 04 	sts	0x04A1, r1	; 0x8004a1 <__TEXT_REGION_LENGTH__+0x7f04a1>
	
	digitalWrite(RFM_RST, 1);
 586:	60 91 86 60 	lds	r22, 0x6086	; 0x806086 <RFM_RST>
 58a:	70 91 87 60 	lds	r23, 0x6087	; 0x806087 <RFM_RST+0x1>
 58e:	80 91 88 60 	lds	r24, 0x6088	; 0x806088 <RFM_RST+0x2>
 592:	41 e0       	ldi	r20, 0x01	; 1
 594:	0e 94 a6 02 	call	0x54c	; 0x54c <digitalWrite>
 598:	08 95       	ret

0000059a <digitalRead>:
		*(pin.port + OUTCLR_OFFSET) = pin.pin; //OUTCLEAR-Register
	}
}

u8 digitalRead(GPIO pin){
	u8 bankData = *(pin.port + IN_OFFSET) & pin.pin;
 59a:	e7 2f       	mov	r30, r23
 59c:	f8 2f       	mov	r31, r24
 59e:	80 85       	ldd	r24, Z+8	; 0x08
	return bankData;
}
 5a0:	86 23       	and	r24, r22
 5a2:	08 95       	ret

000005a4 <createHeader>:
 *  Author: lucas
 */ 

#include "LoRaFunctions.h"

void createHeader(u16 receiver, u16 len, u8 * headerPtr){
 5a4:	fa 01       	movw	r30, r20
	/*memcpy(headerPtr + HDR_RECV_IDX, &receiver, HDR_RECV_LEN);
	memcpy(headerPtr + HDR_SENDER_IDX, &deviceID, HDR_SENDER_LEN);
	memcpy(headerPtr + HDR_MSG_LEN_IDX, &len, HDR_MSGLEN_LEN);*/
	*(headerPtr + HDR_RECV_IDX) = receiver >> 8; 
 5a6:	90 83       	st	Z, r25
	*(headerPtr + HDR_RECV_IDX + 1) = receiver;
 5a8:	81 83       	std	Z+1, r24	; 0x01
	*(headerPtr + HDR_SENDER_IDX) = deviceID >> 8; 
 5aa:	12 82       	std	Z+2, r1	; 0x02
	*(headerPtr + HDR_SENDER_IDX + 1) = deviceID;
 5ac:	81 e0       	ldi	r24, 0x01	; 1
 5ae:	83 83       	std	Z+3, r24	; 0x03
	*(headerPtr + HDR_MSGLEN_IDX) = len >> 8; 
 5b0:	74 83       	std	Z+4, r23	; 0x04
	*(headerPtr + HDR_MSGLEN_IDX + 1) = len;
 5b2:	65 83       	std	Z+5, r22	; 0x05
	*(headerPtr + HDR_MISC_IDX) = 0x00 >> 8; 
 5b4:	16 82       	std	Z+6, r1	; 0x06
	*(headerPtr + HDR_MISC_IDX + 1) = 0x00; 
 5b6:	17 82       	std	Z+7, r1	; 0x07
 5b8:	08 95       	ret

000005ba <main>:
#include "SPIFunctions.h"

 


int main(void){
 5ba:	cf 93       	push	r28
 5bc:	df 93       	push	r29
 5be:	cd b7       	in	r28, 0x3d	; 61
 5c0:	de b7       	in	r29, 0x3e	; 62
 5c2:	c2 59       	subi	r28, 0x92	; 146
 5c4:	d1 09       	sbc	r29, r1
 5c6:	cd bf       	out	0x3d, r28	; 61
 5c8:	de bf       	out	0x3e, r29	; 62
	initializeAVR();
 5ca:	0e 94 99 00 	call	0x132	; 0x132 <initializeAVR>
	initializeGPIO();
 5ce:	0e 94 b0 02 	call	0x560	; 0x560 <initializeGPIO>
	initializeSPI();
 5d2:	0e 94 cd 05 	call	0xb9a	; 0xb9a <initializeSPI>
	initializeLoRa();
 5d6:	0e 94 67 04 	call	0x8ce	; 0x8ce <initializeLoRa>
    /* Replace with your application code */
    
	u8 message[] = {0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55};//{0xAA, 0x55, 0x00, 0xFF, 0xDE, 0xAD, 0xBE, 0xEF};
 5da:	88 e0       	ldi	r24, 0x08	; 8
 5dc:	e0 e0       	ldi	r30, 0x00	; 0
 5de:	f0 e6       	ldi	r31, 0x60	; 96
 5e0:	de 01       	movw	r26, r28
 5e2:	11 96       	adiw	r26, 0x01	; 1
 5e4:	01 90       	ld	r0, Z+
 5e6:	0d 92       	st	X+, r0
 5e8:	8a 95       	dec	r24
 5ea:	e1 f7       	brne	.-8      	; 0x5e4 <main+0x2a>
	u8 msgBuffer[128];
	Message msg = {0x0000, 0x0000, 0x0000, 0x0000, msgBuffer}; 
 5ec:	c7 57       	subi	r28, 0x77	; 119
 5ee:	df 4f       	sbci	r29, 0xFF	; 255
 5f0:	18 82       	st	Y, r1
 5f2:	19 82       	std	Y+1, r1	; 0x01
 5f4:	c9 58       	subi	r28, 0x89	; 137
 5f6:	d0 40       	sbci	r29, 0x00	; 0
 5f8:	c5 57       	subi	r28, 0x75	; 117
 5fa:	df 4f       	sbci	r29, 0xFF	; 255
 5fc:	18 82       	st	Y, r1
 5fe:	19 82       	std	Y+1, r1	; 0x01
 600:	cb 58       	subi	r28, 0x8B	; 139
 602:	d0 40       	sbci	r29, 0x00	; 0
 604:	c3 57       	subi	r28, 0x73	; 115
 606:	df 4f       	sbci	r29, 0xFF	; 255
 608:	18 82       	st	Y, r1
 60a:	19 82       	std	Y+1, r1	; 0x01
 60c:	cd 58       	subi	r28, 0x8D	; 141
 60e:	d0 40       	sbci	r29, 0x00	; 0
 610:	c1 57       	subi	r28, 0x71	; 113
 612:	df 4f       	sbci	r29, 0xFF	; 255
 614:	18 82       	st	Y, r1
 616:	19 82       	std	Y+1, r1	; 0x01
 618:	cf 58       	subi	r28, 0x8F	; 143
 61a:	d0 40       	sbci	r29, 0x00	; 0
 61c:	ce 01       	movw	r24, r28
 61e:	09 96       	adiw	r24, 0x09	; 9
 620:	cf 56       	subi	r28, 0x6F	; 111
 622:	df 4f       	sbci	r29, 0xFF	; 255
 624:	88 83       	st	Y, r24
 626:	99 83       	std	Y+1, r25	; 0x01
 628:	c1 59       	subi	r28, 0x91	; 145
 62a:	d0 40       	sbci	r29, 0x00	; 0
		
	startReceiver(); 
 62c:	0e 94 22 05 	call	0xa44	; 0xa44 <startReceiver>
	
	while (1){
		
		if(!digitalRead(RESET)){
 630:	60 91 0e 60 	lds	r22, 0x600E	; 0x80600e <RESET>
 634:	70 91 0f 60 	lds	r23, 0x600F	; 0x80600f <RESET+0x1>
 638:	80 91 10 60 	lds	r24, 0x6010	; 0x806010 <RESET+0x2>
 63c:	0e 94 cd 02 	call	0x59a	; 0x59a <digitalRead>
 640:	81 11       	cpse	r24, r1
 642:	25 c0       	rjmp	.+74     	; 0x68e <main+0xd4>
			//stopReceiver();
			digitalWrite(LED0, 1);
 644:	60 91 bc 60 	lds	r22, 0x60BC	; 0x8060bc <LED0>
 648:	70 91 bd 60 	lds	r23, 0x60BD	; 0x8060bd <LED0+0x1>
 64c:	80 91 be 60 	lds	r24, 0x60BE	; 0x8060be <LED0+0x2>
 650:	41 e0       	ldi	r20, 0x01	; 1
 652:	0e 94 a6 02 	call	0x54c	; 0x54c <digitalWrite>
			transmit(message, 0x0008, 0x0001);
 656:	41 e0       	ldi	r20, 0x01	; 1
 658:	50 e0       	ldi	r21, 0x00	; 0
 65a:	68 e0       	ldi	r22, 0x08	; 8
 65c:	70 e0       	ldi	r23, 0x00	; 0
 65e:	ce 01       	movw	r24, r28
 660:	01 96       	adiw	r24, 0x01	; 1
 662:	0e 94 ac 04 	call	0x958	; 0x958 <transmit>
			startReceiver();
 666:	0e 94 22 05 	call	0xa44	; 0xa44 <startReceiver>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 66a:	2f ef       	ldi	r18, 0xFF	; 255
 66c:	8d e3       	ldi	r24, 0x3D	; 61
 66e:	99 e4       	ldi	r25, 0x49	; 73
 670:	21 50       	subi	r18, 0x01	; 1
 672:	80 40       	sbci	r24, 0x00	; 0
 674:	90 40       	sbci	r25, 0x00	; 0
 676:	e1 f7       	brne	.-8      	; 0x670 <main+0xb6>
 678:	00 c0       	rjmp	.+0      	; 0x67a <main+0xc0>
 67a:	00 00       	nop
			_delay_ms(1000);
			digitalWrite(LED0, 0);
 67c:	60 91 bc 60 	lds	r22, 0x60BC	; 0x8060bc <LED0>
 680:	70 91 bd 60 	lds	r23, 0x60BD	; 0x8060bd <LED0+0x1>
 684:	80 91 be 60 	lds	r24, 0x60BE	; 0x8060be <LED0+0x2>
 688:	40 e0       	ldi	r20, 0x00	; 0
 68a:	0e 94 a6 02 	call	0x54c	; 0x54c <digitalWrite>
		}
		
		//startReceiver();
		if((RFMInterrupt) handleRFMInterrupts() == rxdone){
 68e:	0e 94 98 03 	call	0x730	; 0x730 <handleRFMInterrupts>
 692:	82 30       	cpi	r24, 0x02	; 2
 694:	69 f6       	brne	.-102    	; 0x630 <main+0x76>
			receive(&msg);
 696:	ce 01       	movw	r24, r28
 698:	87 57       	subi	r24, 0x77	; 119
 69a:	9f 4f       	sbci	r25, 0xFF	; 255
 69c:	0e 94 2f 05 	call	0xa5e	; 0xa5e <receive>
			for(u8 i = 0; i < msg.msglen; i++){
 6a0:	10 e0       	ldi	r17, 0x00	; 0
 6a2:	16 c0       	rjmp	.+44     	; 0x6d0 <main+0x116>
				debugOutput(msg.data[i]);
 6a4:	cf 56       	subi	r28, 0x6F	; 111
 6a6:	df 4f       	sbci	r29, 0xFF	; 255
 6a8:	28 81       	ld	r18, Y
 6aa:	39 81       	ldd	r19, Y+1	; 0x01
 6ac:	c1 59       	subi	r28, 0x91	; 145
 6ae:	d0 40       	sbci	r29, 0x00	; 0
 6b0:	f9 01       	movw	r30, r18
 6b2:	e8 0f       	add	r30, r24
 6b4:	f9 1f       	adc	r31, r25
 6b6:	80 81       	ld	r24, Z
 6b8:	0e 94 ca 03 	call	0x794	; 0x794 <debugOutput>
 6bc:	2f ef       	ldi	r18, 0xFF	; 255
 6be:	82 e5       	ldi	r24, 0x52	; 82
 6c0:	97 e0       	ldi	r25, 0x07	; 7
 6c2:	21 50       	subi	r18, 0x01	; 1
 6c4:	80 40       	sbci	r24, 0x00	; 0
 6c6:	90 40       	sbci	r25, 0x00	; 0
 6c8:	e1 f7       	brne	.-8      	; 0x6c2 <main+0x108>
 6ca:	00 c0       	rjmp	.+0      	; 0x6cc <main+0x112>
 6cc:	00 00       	nop
		}
		
		//startReceiver();
		if((RFMInterrupt) handleRFMInterrupts() == rxdone){
			receive(&msg);
			for(u8 i = 0; i < msg.msglen; i++){
 6ce:	1f 5f       	subi	r17, 0xFF	; 255
 6d0:	81 2f       	mov	r24, r17
 6d2:	90 e0       	ldi	r25, 0x00	; 0
 6d4:	c3 57       	subi	r28, 0x73	; 115
 6d6:	df 4f       	sbci	r29, 0xFF	; 255
 6d8:	28 81       	ld	r18, Y
 6da:	39 81       	ldd	r19, Y+1	; 0x01
 6dc:	cd 58       	subi	r28, 0x8D	; 141
 6de:	d0 40       	sbci	r29, 0x00	; 0
 6e0:	82 17       	cp	r24, r18
 6e2:	93 07       	cpc	r25, r19
 6e4:	f8 f2       	brcs	.-66     	; 0x6a4 <main+0xea>
				debugOutput(msg.data[i]);
				_delay_ms(100);
			}
			stopReceiver();
 6e6:	0e 94 94 04 	call	0x928	; 0x928 <stopReceiver>
			transmit(msg.data, msg.msglen, msg.recv);
 6ea:	c7 57       	subi	r28, 0x77	; 119
 6ec:	df 4f       	sbci	r29, 0xFF	; 255
 6ee:	48 81       	ld	r20, Y
 6f0:	59 81       	ldd	r21, Y+1	; 0x01
 6f2:	c9 58       	subi	r28, 0x89	; 137
 6f4:	d0 40       	sbci	r29, 0x00	; 0
 6f6:	c3 57       	subi	r28, 0x73	; 115
 6f8:	df 4f       	sbci	r29, 0xFF	; 255
 6fa:	68 81       	ld	r22, Y
 6fc:	79 81       	ldd	r23, Y+1	; 0x01
 6fe:	cd 58       	subi	r28, 0x8D	; 141
 700:	d0 40       	sbci	r29, 0x00	; 0
 702:	cf 56       	subi	r28, 0x6F	; 111
 704:	df 4f       	sbci	r29, 0xFF	; 255
 706:	88 81       	ld	r24, Y
 708:	99 81       	ldd	r25, Y+1	; 0x01
 70a:	c1 59       	subi	r28, 0x91	; 145
 70c:	d0 40       	sbci	r29, 0x00	; 0
 70e:	0e 94 ac 04 	call	0x958	; 0x958 <transmit>
			startReceiver();
 712:	0e 94 22 05 	call	0xa44	; 0xa44 <startReceiver>
 716:	8c cf       	rjmp	.-232    	; 0x630 <main+0x76>

00000718 <setPreambleLength>:
	if(opModeReg != (OP_MODE_LORA | OP_MODE_CAD)){
		while(1){}
	}
	
	currentMode = cad; 
}
 718:	cf 93       	push	r28
 71a:	c8 2f       	mov	r28, r24
 71c:	69 2f       	mov	r22, r25
 71e:	80 e2       	ldi	r24, 0x20	; 32
 720:	0e 94 2e 06 	call	0xc5c	; 0xc5c <rfmSpiSend>
 724:	6c 2f       	mov	r22, r28
 726:	81 e2       	ldi	r24, 0x21	; 33
 728:	0e 94 2e 06 	call	0xc5c	; 0xc5c <rfmSpiSend>
 72c:	cf 91       	pop	r28
 72e:	08 95       	ret

00000730 <handleRFMInterrupts>:
 730:	80 91 c5 60 	lds	r24, 0x60C5	; 0x8060c5 <currentMode>
 734:	83 30       	cpi	r24, 0x03	; 3
 736:	71 f4       	brne	.+28     	; 0x754 <handleRFMInterrupts+0x24>
 738:	60 91 4a 60 	lds	r22, 0x604A	; 0x80604a <DIO0>
 73c:	70 91 4b 60 	lds	r23, 0x604B	; 0x80604b <DIO0+0x1>
 740:	80 91 4c 60 	lds	r24, 0x604C	; 0x80604c <DIO0+0x2>
 744:	0e 94 cd 02 	call	0x59a	; 0x59a <digitalRead>
 748:	88 23       	and	r24, r24
 74a:	21 f0       	breq	.+8      	; 0x754 <handleRFMInterrupts+0x24>
 74c:	81 e0       	ldi	r24, 0x01	; 1
 74e:	80 93 c5 60 	sts	0x60C5, r24	; 0x8060c5 <currentMode>
 752:	08 95       	ret
 754:	80 91 c5 60 	lds	r24, 0x60C5	; 0x8060c5 <currentMode>
 758:	86 30       	cpi	r24, 0x06	; 6
 75a:	b1 f4       	brne	.+44     	; 0x788 <handleRFMInterrupts+0x58>
 75c:	60 91 4a 60 	lds	r22, 0x604A	; 0x80604a <DIO0>
 760:	70 91 4b 60 	lds	r23, 0x604B	; 0x80604b <DIO0+0x1>
 764:	80 91 4c 60 	lds	r24, 0x604C	; 0x80604c <DIO0+0x2>
 768:	0e 94 cd 02 	call	0x59a	; 0x59a <digitalRead>
 76c:	81 11       	cpse	r24, r1
 76e:	0e c0       	rjmp	.+28     	; 0x78c <handleRFMInterrupts+0x5c>
 770:	60 91 8c 60 	lds	r22, 0x608C	; 0x80608c <DIO1>
 774:	70 91 8d 60 	lds	r23, 0x608D	; 0x80608d <DIO1+0x1>
 778:	80 91 8e 60 	lds	r24, 0x608E	; 0x80608e <DIO1+0x2>
 77c:	0e 94 cd 02 	call	0x59a	; 0x59a <digitalRead>
 780:	88 23       	and	r24, r24
 782:	31 f0       	breq	.+12     	; 0x790 <handleRFMInterrupts+0x60>
 784:	83 e0       	ldi	r24, 0x03	; 3
 786:	08 95       	ret
 788:	80 e0       	ldi	r24, 0x00	; 0
 78a:	08 95       	ret
 78c:	82 e0       	ldi	r24, 0x02	; 2
 78e:	08 95       	ret
 790:	80 e0       	ldi	r24, 0x00	; 0
 792:	08 95       	ret

00000794 <debugOutput>:
 794:	0f 93       	push	r16
 796:	1f 93       	push	r17
 798:	cf 93       	push	r28
 79a:	c8 2f       	mov	r28, r24
 79c:	48 2f       	mov	r20, r24
 79e:	41 70       	andi	r20, 0x01	; 1
 7a0:	06 e5       	ldi	r16, 0x56	; 86
 7a2:	10 e6       	ldi	r17, 0x60	; 96
 7a4:	f8 01       	movw	r30, r16
 7a6:	60 81       	ld	r22, Z
 7a8:	71 81       	ldd	r23, Z+1	; 0x01
 7aa:	82 81       	ldd	r24, Z+2	; 0x02
 7ac:	0e 94 a6 02 	call	0x54c	; 0x54c <digitalWrite>
 7b0:	4c 2f       	mov	r20, r28
 7b2:	42 70       	andi	r20, 0x02	; 2
 7b4:	50 e0       	ldi	r21, 0x00	; 0
 7b6:	55 95       	asr	r21
 7b8:	47 95       	ror	r20
 7ba:	f8 01       	movw	r30, r16
 7bc:	63 81       	ldd	r22, Z+3	; 0x03
 7be:	74 81       	ldd	r23, Z+4	; 0x04
 7c0:	85 81       	ldd	r24, Z+5	; 0x05
 7c2:	0e 94 a6 02 	call	0x54c	; 0x54c <digitalWrite>
 7c6:	4c 2f       	mov	r20, r28
 7c8:	44 70       	andi	r20, 0x04	; 4
 7ca:	50 e0       	ldi	r21, 0x00	; 0
 7cc:	55 95       	asr	r21
 7ce:	47 95       	ror	r20
 7d0:	55 95       	asr	r21
 7d2:	47 95       	ror	r20
 7d4:	f8 01       	movw	r30, r16
 7d6:	66 81       	ldd	r22, Z+6	; 0x06
 7d8:	77 81       	ldd	r23, Z+7	; 0x07
 7da:	80 85       	ldd	r24, Z+8	; 0x08
 7dc:	0e 94 a6 02 	call	0x54c	; 0x54c <digitalWrite>
 7e0:	4c 2f       	mov	r20, r28
 7e2:	48 70       	andi	r20, 0x08	; 8
 7e4:	50 e0       	ldi	r21, 0x00	; 0
 7e6:	55 95       	asr	r21
 7e8:	47 95       	ror	r20
 7ea:	55 95       	asr	r21
 7ec:	47 95       	ror	r20
 7ee:	55 95       	asr	r21
 7f0:	47 95       	ror	r20
 7f2:	f8 01       	movw	r30, r16
 7f4:	61 85       	ldd	r22, Z+9	; 0x09
 7f6:	72 85       	ldd	r23, Z+10	; 0x0a
 7f8:	83 85       	ldd	r24, Z+11	; 0x0b
 7fa:	0e 94 a6 02 	call	0x54c	; 0x54c <digitalWrite>
 7fe:	4c 2f       	mov	r20, r28
 800:	40 71       	andi	r20, 0x10	; 16
 802:	50 e0       	ldi	r21, 0x00	; 0
 804:	55 95       	asr	r21
 806:	47 95       	ror	r20
 808:	55 95       	asr	r21
 80a:	47 95       	ror	r20
 80c:	55 95       	asr	r21
 80e:	47 95       	ror	r20
 810:	55 95       	asr	r21
 812:	47 95       	ror	r20
 814:	f8 01       	movw	r30, r16
 816:	64 85       	ldd	r22, Z+12	; 0x0c
 818:	75 85       	ldd	r23, Z+13	; 0x0d
 81a:	86 85       	ldd	r24, Z+14	; 0x0e
 81c:	0e 94 a6 02 	call	0x54c	; 0x54c <digitalWrite>
 820:	4c 2f       	mov	r20, r28
 822:	40 72       	andi	r20, 0x20	; 32
 824:	50 e0       	ldi	r21, 0x00	; 0
 826:	55 95       	asr	r21
 828:	47 95       	ror	r20
 82a:	55 95       	asr	r21
 82c:	47 95       	ror	r20
 82e:	55 95       	asr	r21
 830:	47 95       	ror	r20
 832:	55 95       	asr	r21
 834:	47 95       	ror	r20
 836:	55 95       	asr	r21
 838:	47 95       	ror	r20
 83a:	f8 01       	movw	r30, r16
 83c:	67 85       	ldd	r22, Z+15	; 0x0f
 83e:	70 89       	ldd	r23, Z+16	; 0x10
 840:	81 89       	ldd	r24, Z+17	; 0x11
 842:	0e 94 a6 02 	call	0x54c	; 0x54c <digitalWrite>
 846:	4c 2f       	mov	r20, r28
 848:	40 74       	andi	r20, 0x40	; 64
 84a:	50 e0       	ldi	r21, 0x00	; 0
 84c:	04 2e       	mov	r0, r20
 84e:	45 2f       	mov	r20, r21
 850:	00 0c       	add	r0, r0
 852:	44 1f       	adc	r20, r20
 854:	55 0b       	sbc	r21, r21
 856:	00 0c       	add	r0, r0
 858:	44 1f       	adc	r20, r20
 85a:	55 1f       	adc	r21, r21
 85c:	f8 01       	movw	r30, r16
 85e:	62 89       	ldd	r22, Z+18	; 0x12
 860:	73 89       	ldd	r23, Z+19	; 0x13
 862:	84 89       	ldd	r24, Z+20	; 0x14
 864:	0e 94 a6 02 	call	0x54c	; 0x54c <digitalWrite>
 868:	4c 2f       	mov	r20, r28
 86a:	44 1f       	adc	r20, r20
 86c:	44 27       	eor	r20, r20
 86e:	44 1f       	adc	r20, r20
 870:	f8 01       	movw	r30, r16
 872:	65 89       	ldd	r22, Z+21	; 0x15
 874:	76 89       	ldd	r23, Z+22	; 0x16
 876:	87 89       	ldd	r24, Z+23	; 0x17
 878:	0e 94 a6 02 	call	0x54c	; 0x54c <digitalWrite>
 87c:	cf 91       	pop	r28
 87e:	1f 91       	pop	r17
 880:	0f 91       	pop	r16
 882:	08 95       	ret

00000884 <setSleepMode>:
 884:	cf 93       	push	r28
 886:	60 e8       	ldi	r22, 0x80	; 128
 888:	81 e0       	ldi	r24, 0x01	; 1
 88a:	0e 94 2e 06 	call	0xc5c	; 0xc5c <rfmSpiSend>
 88e:	81 e0       	ldi	r24, 0x01	; 1
 890:	0e 94 0a 06 	call	0xc14	; 0xc14 <rfmSpiRecv>
 894:	c8 2f       	mov	r28, r24
 896:	0e 94 ca 03 	call	0x794	; 0x794 <debugOutput>
 89a:	c0 38       	cpi	r28, 0x80	; 128
 89c:	09 f0       	breq	.+2      	; 0x8a0 <setSleepMode+0x1c>
 89e:	ff cf       	rjmp	.-2      	; 0x89e <setSleepMode+0x1a>
 8a0:	10 92 c5 60 	sts	0x60C5, r1	; 0x8060c5 <currentMode>
 8a4:	cf 91       	pop	r28
 8a6:	08 95       	ret

000008a8 <setStdbyMode>:
 8a8:	cf 93       	push	r28
 8aa:	61 e8       	ldi	r22, 0x81	; 129
 8ac:	81 e0       	ldi	r24, 0x01	; 1
 8ae:	0e 94 2e 06 	call	0xc5c	; 0xc5c <rfmSpiSend>
 8b2:	81 e0       	ldi	r24, 0x01	; 1
 8b4:	0e 94 0a 06 	call	0xc14	; 0xc14 <rfmSpiRecv>
 8b8:	c8 2f       	mov	r28, r24
 8ba:	0e 94 ca 03 	call	0x794	; 0x794 <debugOutput>
 8be:	c1 38       	cpi	r28, 0x81	; 129
 8c0:	09 f0       	breq	.+2      	; 0x8c4 <setStdbyMode+0x1c>
 8c2:	ff cf       	rjmp	.-2      	; 0x8c2 <setStdbyMode+0x1a>
 8c4:	81 e0       	ldi	r24, 0x01	; 1
 8c6:	80 93 c5 60 	sts	0x60C5, r24	; 0x8060c5 <currentMode>
 8ca:	cf 91       	pop	r28
 8cc:	08 95       	ret

000008ce <initializeLoRa>:
 8ce:	0e 94 42 04 	call	0x884	; 0x884 <setSleepMode>
 8d2:	60 e0       	ldi	r22, 0x00	; 0
 8d4:	8e e0       	ldi	r24, 0x0E	; 14
 8d6:	0e 94 2e 06 	call	0xc5c	; 0xc5c <rfmSpiSend>
 8da:	60 e0       	ldi	r22, 0x00	; 0
 8dc:	8f e0       	ldi	r24, 0x0F	; 15
 8de:	0e 94 2e 06 	call	0xc5c	; 0xc5c <rfmSpiSend>
 8e2:	0e 94 54 04 	call	0x8a8	; 0x8a8 <setStdbyMode>
 8e6:	68 e7       	ldi	r22, 0x78	; 120
 8e8:	8d e1       	ldi	r24, 0x1D	; 29
 8ea:	0e 94 2e 06 	call	0xc5c	; 0xc5c <rfmSpiSend>
 8ee:	64 ec       	ldi	r22, 0xC4	; 196
 8f0:	8e e1       	ldi	r24, 0x1E	; 30
 8f2:	0e 94 2e 06 	call	0xc5c	; 0xc5c <rfmSpiSend>
 8f6:	60 e0       	ldi	r22, 0x00	; 0
 8f8:	86 e2       	ldi	r24, 0x26	; 38
 8fa:	0e 94 2e 06 	call	0xc5c	; 0xc5c <rfmSpiSend>
 8fe:	88 e0       	ldi	r24, 0x08	; 8
 900:	90 e0       	ldi	r25, 0x00	; 0
 902:	0e 94 8c 03 	call	0x718	; 0x718 <setPreambleLength>
 906:	60 ee       	ldi	r22, 0xE0	; 224
 908:	86 e0       	ldi	r24, 0x06	; 6
 90a:	0e 94 2e 06 	call	0xc5c	; 0xc5c <rfmSpiSend>
 90e:	60 e0       	ldi	r22, 0x00	; 0
 910:	87 e0       	ldi	r24, 0x07	; 7
 912:	0e 94 2e 06 	call	0xc5c	; 0xc5c <rfmSpiSend>
 916:	60 e0       	ldi	r22, 0x00	; 0
 918:	88 e0       	ldi	r24, 0x08	; 8
 91a:	0e 94 2e 06 	call	0xc5c	; 0xc5c <rfmSpiSend>
 91e:	6a ef       	ldi	r22, 0xFA	; 250
 920:	89 e0       	ldi	r24, 0x09	; 9
 922:	0e 94 2e 06 	call	0xc5c	; 0xc5c <rfmSpiSend>
 926:	08 95       	ret

00000928 <stopReceiver>:
 928:	0e 94 54 04 	call	0x8a8	; 0x8a8 <setStdbyMode>
 92c:	6f ef       	ldi	r22, 0xFF	; 255
 92e:	82 e1       	ldi	r24, 0x12	; 18
 930:	0e 94 2e 06 	call	0xc5c	; 0xc5c <rfmSpiSend>
 934:	60 e0       	ldi	r22, 0x00	; 0
 936:	80 e1       	ldi	r24, 0x10	; 16
 938:	0e 94 2e 06 	call	0xc5c	; 0xc5c <rfmSpiSend>
 93c:	08 95       	ret

0000093e <setTXMode>:
 93e:	63 e8       	ldi	r22, 0x83	; 131
 940:	81 e0       	ldi	r24, 0x01	; 1
 942:	0e 94 2e 06 	call	0xc5c	; 0xc5c <rfmSpiSend>
 946:	81 e0       	ldi	r24, 0x01	; 1
 948:	0e 94 0a 06 	call	0xc14	; 0xc14 <rfmSpiRecv>
 94c:	0e 94 ca 03 	call	0x794	; 0x794 <debugOutput>
 950:	83 e0       	ldi	r24, 0x03	; 3
 952:	80 93 c5 60 	sts	0x60C5, r24	; 0x8060c5 <currentMode>
 956:	08 95       	ret

00000958 <transmit>:
 958:	cf 92       	push	r12
 95a:	df 92       	push	r13
 95c:	ef 92       	push	r14
 95e:	ff 92       	push	r15
 960:	0f 93       	push	r16
 962:	1f 93       	push	r17
 964:	cf 93       	push	r28
 966:	df 93       	push	r29
 968:	cd b7       	in	r28, 0x3d	; 61
 96a:	de b7       	in	r29, 0x3e	; 62
 96c:	28 97       	sbiw	r28, 0x08	; 8
 96e:	cd bf       	out	0x3d, r28	; 61
 970:	de bf       	out	0x3e, r29	; 62
 972:	6c 01       	movw	r12, r24
 974:	7b 01       	movw	r14, r22
 976:	ca 01       	movw	r24, r20
 978:	ae 01       	movw	r20, r28
 97a:	4f 5f       	subi	r20, 0xFF	; 255
 97c:	5f 4f       	sbci	r21, 0xFF	; 255
 97e:	28 e0       	ldi	r18, 0x08	; 8
 980:	fa 01       	movw	r30, r20
 982:	11 92       	st	Z+, r1
 984:	2a 95       	dec	r18
 986:	e9 f7       	brne	.-6      	; 0x982 <transmit+0x2a>
 988:	0e 94 d2 02 	call	0x5a4	; 0x5a4 <createHeader>
 98c:	60 e0       	ldi	r22, 0x00	; 0
 98e:	8d e0       	ldi	r24, 0x0D	; 13
 990:	0e 94 2e 06 	call	0xc5c	; 0xc5c <rfmSpiSend>
 994:	00 e0       	ldi	r16, 0x00	; 0
 996:	10 e0       	ldi	r17, 0x00	; 0
 998:	0c c0       	rjmp	.+24     	; 0x9b2 <transmit+0x5a>
 99a:	e1 e0       	ldi	r30, 0x01	; 1
 99c:	f0 e0       	ldi	r31, 0x00	; 0
 99e:	ec 0f       	add	r30, r28
 9a0:	fd 1f       	adc	r31, r29
 9a2:	e0 0f       	add	r30, r16
 9a4:	f1 1f       	adc	r31, r17
 9a6:	60 81       	ld	r22, Z
 9a8:	80 e0       	ldi	r24, 0x00	; 0
 9aa:	0e 94 2e 06 	call	0xc5c	; 0xc5c <rfmSpiSend>
 9ae:	0f 5f       	subi	r16, 0xFF	; 255
 9b0:	1f 4f       	sbci	r17, 0xFF	; 255
 9b2:	08 30       	cpi	r16, 0x08	; 8
 9b4:	11 05       	cpc	r17, r1
 9b6:	88 f3       	brcs	.-30     	; 0x99a <transmit+0x42>
 9b8:	00 e0       	ldi	r16, 0x00	; 0
 9ba:	10 e0       	ldi	r17, 0x00	; 0
 9bc:	09 c0       	rjmp	.+18     	; 0x9d0 <transmit+0x78>
 9be:	f6 01       	movw	r30, r12
 9c0:	e0 0f       	add	r30, r16
 9c2:	f1 1f       	adc	r31, r17
 9c4:	60 81       	ld	r22, Z
 9c6:	80 e0       	ldi	r24, 0x00	; 0
 9c8:	0e 94 2e 06 	call	0xc5c	; 0xc5c <rfmSpiSend>
 9cc:	0f 5f       	subi	r16, 0xFF	; 255
 9ce:	1f 4f       	sbci	r17, 0xFF	; 255
 9d0:	0e 15       	cp	r16, r14
 9d2:	1f 05       	cpc	r17, r15
 9d4:	a0 f3       	brcs	.-24     	; 0x9be <transmit+0x66>
 9d6:	60 e4       	ldi	r22, 0x40	; 64
 9d8:	80 e4       	ldi	r24, 0x40	; 64
 9da:	0e 94 2e 06 	call	0xc5c	; 0xc5c <rfmSpiSend>
 9de:	68 e0       	ldi	r22, 0x08	; 8
 9e0:	6e 0d       	add	r22, r14
 9e2:	82 e2       	ldi	r24, 0x22	; 34
 9e4:	0e 94 2e 06 	call	0xc5c	; 0xc5c <rfmSpiSend>
 9e8:	0e 94 9f 04 	call	0x93e	; 0x93e <setTXMode>
 9ec:	0e 94 98 03 	call	0x730	; 0x730 <handleRFMInterrupts>
 9f0:	81 30       	cpi	r24, 0x01	; 1
 9f2:	e1 f7       	brne	.-8      	; 0x9ec <transmit+0x94>
 9f4:	28 96       	adiw	r28, 0x08	; 8
 9f6:	cd bf       	out	0x3d, r28	; 61
 9f8:	de bf       	out	0x3e, r29	; 62
 9fa:	df 91       	pop	r29
 9fc:	cf 91       	pop	r28
 9fe:	1f 91       	pop	r17
 a00:	0f 91       	pop	r16
 a02:	ff 90       	pop	r15
 a04:	ef 90       	pop	r14
 a06:	df 90       	pop	r13
 a08:	cf 90       	pop	r12
 a0a:	08 95       	ret

00000a0c <setRXContinuousMode>:
 a0c:	cf 93       	push	r28
 a0e:	65 e8       	ldi	r22, 0x85	; 133
 a10:	81 e0       	ldi	r24, 0x01	; 1
 a12:	0e 94 2e 06 	call	0xc5c	; 0xc5c <rfmSpiSend>
 a16:	2f e7       	ldi	r18, 0x7F	; 127
 a18:	89 ea       	ldi	r24, 0xA9	; 169
 a1a:	93 e0       	ldi	r25, 0x03	; 3
 a1c:	21 50       	subi	r18, 0x01	; 1
 a1e:	80 40       	sbci	r24, 0x00	; 0
 a20:	90 40       	sbci	r25, 0x00	; 0
 a22:	e1 f7       	brne	.-8      	; 0xa1c <setRXContinuousMode+0x10>
 a24:	00 c0       	rjmp	.+0      	; 0xa26 <setRXContinuousMode+0x1a>
 a26:	00 00       	nop
 a28:	81 e0       	ldi	r24, 0x01	; 1
 a2a:	0e 94 0a 06 	call	0xc14	; 0xc14 <rfmSpiRecv>
 a2e:	c8 2f       	mov	r28, r24
 a30:	0e 94 ca 03 	call	0x794	; 0x794 <debugOutput>
 a34:	c5 38       	cpi	r28, 0x85	; 133
 a36:	09 f0       	breq	.+2      	; 0xa3a <setRXContinuousMode+0x2e>
 a38:	ff cf       	rjmp	.-2      	; 0xa38 <setRXContinuousMode+0x2c>
 a3a:	86 e0       	ldi	r24, 0x06	; 6
 a3c:	80 93 c5 60 	sts	0x60C5, r24	; 0x8060c5 <currentMode>
 a40:	cf 91       	pop	r28
 a42:	08 95       	ret

00000a44 <startReceiver>:
 a44:	0e 94 54 04 	call	0x8a8	; 0x8a8 <setStdbyMode>
 a48:	6f ef       	ldi	r22, 0xFF	; 255
 a4a:	82 e1       	ldi	r24, 0x12	; 18
 a4c:	0e 94 2e 06 	call	0xc5c	; 0xc5c <rfmSpiSend>
 a50:	0e 94 06 05 	call	0xa0c	; 0xa0c <setRXContinuousMode>
 a54:	60 e0       	ldi	r22, 0x00	; 0
 a56:	80 e4       	ldi	r24, 0x40	; 64
 a58:	0e 94 2e 06 	call	0xc5c	; 0xc5c <rfmSpiSend>
 a5c:	08 95       	ret

00000a5e <receive>:
	while(handleRFMInterrupts() != txdone){
		
	}
}

void receive(Message * msg){
 a5e:	cf 92       	push	r12
 a60:	df 92       	push	r13
 a62:	ef 92       	push	r14
 a64:	ff 92       	push	r15
 a66:	0f 93       	push	r16
 a68:	1f 93       	push	r17
 a6a:	cf 93       	push	r28
 a6c:	df 93       	push	r29
 a6e:	cd b7       	in	r28, 0x3d	; 61
 a70:	de b7       	in	r29, 0x3e	; 62
 a72:	28 97       	sbiw	r28, 0x08	; 8
 a74:	cd bf       	out	0x3d, r28	; 61
 a76:	de bf       	out	0x3e, r29	; 62
 a78:	6c 01       	movw	r12, r24
	
	//Read out the number of received bytes
	u8 msglen = rfmSpiRecv(REG_RX_NB_BYTES);
 a7a:	83 e1       	ldi	r24, 0x13	; 19
 a7c:	0e 94 0a 06 	call	0xc14	; 0xc14 <rfmSpiRecv>
 a80:	08 2f       	mov	r16, r24
	
	//Create a buffer with the required size. This may include any additional headers brought back by the RFM95W.
	while(msglen < HDR_LEN){
 a82:	08 30       	cpi	r16, 0x08	; 8
 a84:	f0 f3       	brcs	.-4      	; 0xa82 <receive+0x24>
	}
	
	//Create buffer for storing the header information.
	//To save time, this function checks whether the header info is correct. 
	u8 hdrBuffer[HDR_LEN];
	memset(hdrBuffer, 0, HDR_LEN * sizeof(u8));
 a86:	fe 01       	movw	r30, r28
 a88:	31 96       	adiw	r30, 0x01	; 1
 a8a:	88 e0       	ldi	r24, 0x08	; 8
 a8c:	df 01       	movw	r26, r30
 a8e:	1d 92       	st	X+, r1
 a90:	8a 95       	dec	r24
 a92:	e9 f7       	brne	.-6      	; 0xa8e <receive+0x30>
	
	u8 currentAddr = rfmSpiRecv(REG_FIFO_RX_CURRENT_ADDR);
 a94:	80 e1       	ldi	r24, 0x10	; 16
 a96:	0e 94 0a 06 	call	0xc14	; 0xc14 <rfmSpiRecv>
	
	//Set FIFO to the byte where the RX data starts
	rfmSpiSend(REG_FIFO_ADDR_PTR, currentAddr);
 a9a:	68 2f       	mov	r22, r24
 a9c:	8d e0       	ldi	r24, 0x0D	; 13
 a9e:	0e 94 2e 06 	call	0xc5c	; 0xc5c <rfmSpiSend>
	
	for(u8 i = 0; i < HDR_LEN; i++){
 aa2:	10 e0       	ldi	r17, 0x00	; 0
 aa4:	18 c0       	rjmp	.+48     	; 0xad6 <receive+0x78>
		hdrBuffer[i] = rfmSpiRecv(REG_FIFO);;
 aa6:	e1 2e       	mov	r14, r17
 aa8:	f1 2c       	mov	r15, r1
 aaa:	80 e0       	ldi	r24, 0x00	; 0
 aac:	0e 94 0a 06 	call	0xc14	; 0xc14 <rfmSpiRecv>
 ab0:	e1 e0       	ldi	r30, 0x01	; 1
 ab2:	f0 e0       	ldi	r31, 0x00	; 0
 ab4:	ec 0f       	add	r30, r28
 ab6:	fd 1f       	adc	r31, r29
 ab8:	ee 0d       	add	r30, r14
 aba:	ff 1d       	adc	r31, r15
 abc:	80 83       	st	Z, r24
		debugOutput(hdrBuffer[i]);
 abe:	0e 94 ca 03 	call	0x794	; 0x794 <debugOutput>
 ac2:	bf ef       	ldi	r27, 0xFF	; 255
 ac4:	e2 e5       	ldi	r30, 0x52	; 82
 ac6:	f7 e0       	ldi	r31, 0x07	; 7
 ac8:	b1 50       	subi	r27, 0x01	; 1
 aca:	e0 40       	sbci	r30, 0x00	; 0
 acc:	f0 40       	sbci	r31, 0x00	; 0
 ace:	e1 f7       	brne	.-8      	; 0xac8 <receive+0x6a>
 ad0:	00 c0       	rjmp	.+0      	; 0xad2 <receive+0x74>
 ad2:	00 00       	nop
	u8 currentAddr = rfmSpiRecv(REG_FIFO_RX_CURRENT_ADDR);
	
	//Set FIFO to the byte where the RX data starts
	rfmSpiSend(REG_FIFO_ADDR_PTR, currentAddr);
	
	for(u8 i = 0; i < HDR_LEN; i++){
 ad4:	1f 5f       	subi	r17, 0xFF	; 255
 ad6:	18 30       	cpi	r17, 0x08	; 8
 ad8:	30 f3       	brcs	.-52     	; 0xaa6 <receive+0x48>
		hdrBuffer[i] = rfmSpiRecv(REG_FIFO);;
		debugOutput(hdrBuffer[i]);
		_delay_ms(100);
	}
	
	msg->recv = (hdrBuffer[HDR_RECV_IDX] << 8) + hdrBuffer[HDR_RECV_IDX + 1];
 ada:	89 81       	ldd	r24, Y+1	; 0x01
 adc:	90 e0       	ldi	r25, 0x00	; 0
 ade:	98 2f       	mov	r25, r24
 ae0:	88 27       	eor	r24, r24
 ae2:	2a 81       	ldd	r18, Y+2	; 0x02
 ae4:	82 0f       	add	r24, r18
 ae6:	91 1d       	adc	r25, r1
 ae8:	d6 01       	movw	r26, r12
 aea:	8d 93       	st	X+, r24
 aec:	9c 93       	st	X, r25
 aee:	11 97       	sbiw	r26, 0x01	; 1
	msg->sender = (hdrBuffer[HDR_SENDER_IDX] << 8) + hdrBuffer[HDR_SENDER_IDX + 1];
 af0:	2b 81       	ldd	r18, Y+3	; 0x03
 af2:	30 e0       	ldi	r19, 0x00	; 0
 af4:	32 2f       	mov	r19, r18
 af6:	22 27       	eor	r18, r18
 af8:	4c 81       	ldd	r20, Y+4	; 0x04
 afa:	24 0f       	add	r18, r20
 afc:	31 1d       	adc	r19, r1
 afe:	12 96       	adiw	r26, 0x02	; 2
 b00:	2d 93       	st	X+, r18
 b02:	3c 93       	st	X, r19
 b04:	13 97       	sbiw	r26, 0x03	; 3
	msg->msglen = (hdrBuffer[HDR_MSGLEN_IDX] << 8) + hdrBuffer[HDR_MSGLEN_IDX + 1];
 b06:	2d 81       	ldd	r18, Y+5	; 0x05
 b08:	30 e0       	ldi	r19, 0x00	; 0
 b0a:	32 2f       	mov	r19, r18
 b0c:	22 27       	eor	r18, r18
 b0e:	4e 81       	ldd	r20, Y+6	; 0x06
 b10:	24 0f       	add	r18, r20
 b12:	31 1d       	adc	r19, r1
 b14:	14 96       	adiw	r26, 0x04	; 4
 b16:	2d 93       	st	X+, r18
 b18:	3c 93       	st	X, r19
 b1a:	15 97       	sbiw	r26, 0x05	; 5
	msg->misc = (hdrBuffer[HDR_MISC_IDX] << 8) + hdrBuffer[HDR_MISC_IDX + 1];
 b1c:	4f 81       	ldd	r20, Y+7	; 0x07
 b1e:	50 e0       	ldi	r21, 0x00	; 0
 b20:	54 2f       	mov	r21, r20
 b22:	44 27       	eor	r20, r20
 b24:	68 85       	ldd	r22, Y+8	; 0x08
 b26:	46 0f       	add	r20, r22
 b28:	51 1d       	adc	r21, r1
 b2a:	16 96       	adiw	r26, 0x06	; 6
 b2c:	4d 93       	st	X+, r20
 b2e:	5c 93       	st	X, r21
 b30:	17 97       	sbiw	r26, 0x07	; 7
	
	//Check if recipient is right
	if(msg->recv == deviceID){
 b32:	01 97       	sbiw	r24, 0x01	; 1
 b34:	d9 f4       	brne	.+54     	; 0xb6c <receive+0x10e>
		
		u8 hdrLen = (u8) HDR_LEN;
		
		//Check if message length matches the received message length
		while(msg->msglen != msglen - hdrLen){
 b36:	80 2f       	mov	r24, r16
 b38:	90 e0       	ldi	r25, 0x00	; 0
 b3a:	08 97       	sbiw	r24, 0x08	; 8
 b3c:	28 17       	cp	r18, r24
 b3e:	39 07       	cpc	r19, r25
 b40:	d1 f7       	brne	.-12     	; 0xb36 <receive+0xd8>
 b42:	10 e0       	ldi	r17, 0x00	; 0
 b44:	0b c0       	rjmp	.+22     	; 0xb5c <receive+0xfe>
		
		}
		
		//Receive the actual message
		for(u8 i = 0; i < msg->msglen; i++)
			msg->data[i] = rfmSpiRecv(REG_FIFO);;
 b46:	f6 01       	movw	r30, r12
 b48:	e0 84       	ldd	r14, Z+8	; 0x08
 b4a:	f1 84       	ldd	r15, Z+9	; 0x09
 b4c:	e8 0e       	add	r14, r24
 b4e:	f9 1e       	adc	r15, r25
 b50:	80 e0       	ldi	r24, 0x00	; 0
 b52:	0e 94 0a 06 	call	0xc14	; 0xc14 <rfmSpiRecv>
 b56:	d7 01       	movw	r26, r14
 b58:	8c 93       	st	X, r24
		while(msg->msglen != msglen - hdrLen){
		
		}
		
		//Receive the actual message
		for(u8 i = 0; i < msg->msglen; i++)
 b5a:	1f 5f       	subi	r17, 0xFF	; 255
 b5c:	81 2f       	mov	r24, r17
 b5e:	90 e0       	ldi	r25, 0x00	; 0
 b60:	f6 01       	movw	r30, r12
 b62:	24 81       	ldd	r18, Z+4	; 0x04
 b64:	35 81       	ldd	r19, Z+5	; 0x05
 b66:	82 17       	cp	r24, r18
 b68:	93 07       	cpc	r25, r19
 b6a:	68 f3       	brcs	.-38     	; 0xb46 <receive+0xe8>
			msg->data[i] = rfmSpiRecv(REG_FIFO);;
	}
	
	
	//Clear interrupt flags
	rfmSpiSend(REG_IRQ_FLAGS, 0xFF);
 b6c:	6f ef       	ldi	r22, 0xFF	; 255
 b6e:	82 e1       	ldi	r24, 0x12	; 18
 b70:	0e 94 2e 06 	call	0xc5c	; 0xc5c <rfmSpiSend>
	
	//Read RSSI Value
	s16 rssi = rfmSpiRecv(REG_PKT_RSSI_VALUE) - 137;
 b74:	8a e1       	ldi	r24, 0x1A	; 26
 b76:	0e 94 0a 06 	call	0xc14	; 0xc14 <rfmSpiRecv>
	
	//Reset RX Address pointer
	rfmSpiSend(REG_FIFO_RX_CURRENT_ADDR, 0x00);
 b7a:	60 e0       	ldi	r22, 0x00	; 0
 b7c:	80 e1       	ldi	r24, 0x10	; 16
 b7e:	0e 94 2e 06 	call	0xc5c	; 0xc5c <rfmSpiSend>
}
 b82:	28 96       	adiw	r28, 0x08	; 8
 b84:	cd bf       	out	0x3d, r28	; 61
 b86:	de bf       	out	0x3e, r29	; 62
 b88:	df 91       	pop	r29
 b8a:	cf 91       	pop	r28
 b8c:	1f 91       	pop	r17
 b8e:	0f 91       	pop	r16
 b90:	ff 90       	pop	r15
 b92:	ef 90       	pop	r14
 b94:	df 90       	pop	r13
 b96:	cf 90       	pop	r12
 b98:	08 95       	ret

00000b9a <initializeSPI>:
 */ 

#include "SPIFunctions.h"

void initializeSPI(){
	PORTMUX_SPIROUTEA = 0b00000001; //Set SPI0 to alternate position (PE0..4)
 b9a:	81 e0       	ldi	r24, 0x01	; 1
 b9c:	80 93 e4 05 	sts	0x05E4, r24	; 0x8005e4 <__TEXT_REGION_LENGTH__+0x7f05e4>
	//PORTE_DIRSET = 0b00001101; //Set SS, SCK, MOSI to output
	SPI0_CTRLA = 0b00100000; //Set to Master Mode and enable SPI with prescaler /4, do not enable yet
 ba0:	e0 e4       	ldi	r30, 0x40	; 64
 ba2:	f9 e0       	ldi	r31, 0x09	; 9
 ba4:	80 e2       	ldi	r24, 0x20	; 32
 ba6:	80 83       	st	Z, r24
	SPI0_CTRLB = 0b10000000; //BUFEN
 ba8:	80 e8       	ldi	r24, 0x80	; 128
 baa:	80 93 41 09 	sts	0x0941, r24	; 0x800941 <__TEXT_REGION_LENGTH__+0x7f0941>
	SPI0_INTCTRL = 0b11100000; //Enable RX/TX Complete interrupts as well as Data Register Empty Interrupt 00000001
 bae:	80 ee       	ldi	r24, 0xE0	; 224
 bb0:	80 93 42 09 	sts	0x0942, r24	; 0x800942 <__TEXT_REGION_LENGTH__+0x7f0942>
	SPI0_CTRLA |= 0b00000001; 
 bb4:	80 81       	ld	r24, Z
 bb6:	81 60       	ori	r24, 0x01	; 1
 bb8:	80 83       	st	Z, r24
 bba:	8f e6       	ldi	r24, 0x6F	; 111
 bbc:	97 e1       	ldi	r25, 0x17	; 23
 bbe:	01 97       	sbiw	r24, 0x01	; 1
 bc0:	f1 f7       	brne	.-4      	; 0xbbe <initializeSPI+0x24>
 bc2:	00 c0       	rjmp	.+0      	; 0xbc4 <initializeSPI+0x2a>
 bc4:	00 00       	nop
 bc6:	08 95       	ret

00000bc8 <spiRecv>:
	return data; 
}

u8 spiRecv(){
	u8 data; 
	while((SPI0.INTFLAGS & INTFLAG_DREIF) == 0);
 bc8:	80 91 43 09 	lds	r24, 0x0943	; 0x800943 <__TEXT_REGION_LENGTH__+0x7f0943>
 bcc:	85 ff       	sbrs	r24, 5
 bce:	fc cf       	rjmp	.-8      	; 0xbc8 <spiRecv>
	SPI0.DATA = 0xFF; //Send empty bits for clock to continue
 bd0:	8f ef       	ldi	r24, 0xFF	; 255
 bd2:	80 93 44 09 	sts	0x0944, r24	; 0x800944 <__TEXT_REGION_LENGTH__+0x7f0944>
	while((SPI0.INTFLAGS & INTFLAG_TXCIF) == 0);
 bd6:	80 91 43 09 	lds	r24, 0x0943	; 0x800943 <__TEXT_REGION_LENGTH__+0x7f0943>
 bda:	86 ff       	sbrs	r24, 6
 bdc:	fc cf       	rjmp	.-8      	; 0xbd6 <spiRecv+0xe>
	data = (u8) SPI0.DATA; //Data is initially 0
 bde:	80 91 44 09 	lds	r24, 0x0944	; 0x800944 <__TEXT_REGION_LENGTH__+0x7f0944>
	
	//Read only the last byte of buffer
	while(SPI0.INTFLAGS & INTFLAG_RXCIF){
 be2:	02 c0       	rjmp	.+4      	; 0xbe8 <spiRecv+0x20>
		data = (u8) SPI0.DATA; 
 be4:	80 91 44 09 	lds	r24, 0x0944	; 0x800944 <__TEXT_REGION_LENGTH__+0x7f0944>
	SPI0.DATA = 0xFF; //Send empty bits for clock to continue
	while((SPI0.INTFLAGS & INTFLAG_TXCIF) == 0);
	data = (u8) SPI0.DATA; //Data is initially 0
	
	//Read only the last byte of buffer
	while(SPI0.INTFLAGS & INTFLAG_RXCIF){
 be8:	90 91 43 09 	lds	r25, 0x0943	; 0x800943 <__TEXT_REGION_LENGTH__+0x7f0943>
 bec:	99 23       	and	r25, r25
 bee:	d4 f3       	brlt	.-12     	; 0xbe4 <spiRecv+0x1c>
		data = (u8) SPI0.DATA; 
	}
	
	SPI0_INTFLAGS = 0xC0; //Reset Interrupts
 bf0:	90 ec       	ldi	r25, 0xC0	; 192
 bf2:	90 93 43 09 	sts	0x0943, r25	; 0x800943 <__TEXT_REGION_LENGTH__+0x7f0943>
	return data;
	
}
 bf6:	08 95       	ret

00000bf8 <spiSend>:
	digitalWrite(RFM_SS, 1);
	SPI0_INTFLAGS = 0xC0;
}

void spiSend(u8 data){
	while((SPI0.INTFLAGS & INTFLAG_DREIF) == 0);
 bf8:	90 91 43 09 	lds	r25, 0x0943	; 0x800943 <__TEXT_REGION_LENGTH__+0x7f0943>
 bfc:	95 ff       	sbrs	r25, 5
 bfe:	fc cf       	rjmp	.-8      	; 0xbf8 <spiSend>
	SPI0.DATA = data;
 c00:	80 93 44 09 	sts	0x0944, r24	; 0x800944 <__TEXT_REGION_LENGTH__+0x7f0944>
	while((SPI0.INTFLAGS & INTFLAG_TXCIF) == 0);
 c04:	80 91 43 09 	lds	r24, 0x0943	; 0x800943 <__TEXT_REGION_LENGTH__+0x7f0943>
 c08:	86 ff       	sbrs	r24, 6
 c0a:	fc cf       	rjmp	.-8      	; 0xc04 <spiSend+0xc>
	SPI0_INTFLAGS = 0xC0; //Reset Interrupts
 c0c:	80 ec       	ldi	r24, 0xC0	; 192
 c0e:	80 93 43 09 	sts	0x0943, r24	; 0x800943 <__TEXT_REGION_LENGTH__+0x7f0943>
 c12:	08 95       	ret

00000c14 <rfmSpiRecv>:
	SPI0_CTRLA |= 0b00000001; 

	_delay_ms(1); //Minimum before use
}

u8 rfmSpiRecv(u8 addr){
 c14:	cf 93       	push	r28
 c16:	c8 2f       	mov	r28, r24
	digitalWrite(RFM_SS, 0);
 c18:	60 91 a1 60 	lds	r22, 0x60A1	; 0x8060a1 <RFM_SS>
 c1c:	70 91 a2 60 	lds	r23, 0x60A2	; 0x8060a2 <RFM_SS+0x1>
 c20:	80 91 a3 60 	lds	r24, 0x60A3	; 0x8060a3 <RFM_SS+0x2>
 c24:	40 e0       	ldi	r20, 0x00	; 0
 c26:	0e 94 a6 02 	call	0x54c	; 0x54c <digitalWrite>
	spiSend(RFM_SPI_READ | addr);
 c2a:	8c 2f       	mov	r24, r28
 c2c:	0e 94 fc 05 	call	0xbf8	; 0xbf8 <spiSend>
	u8 temp;
	for(u8 i = 0; i < 2; i++){ //Clear read buffer because the RFM95W sends register contents even during writes
 c30:	80 e0       	ldi	r24, 0x00	; 0
 c32:	03 c0       	rjmp	.+6      	; 0xc3a <rfmSpiRecv+0x26>
		temp = (u8) SPI0.DATA;
 c34:	90 91 44 09 	lds	r25, 0x0944	; 0x800944 <__TEXT_REGION_LENGTH__+0x7f0944>

u8 rfmSpiRecv(u8 addr){
	digitalWrite(RFM_SS, 0);
	spiSend(RFM_SPI_READ | addr);
	u8 temp;
	for(u8 i = 0; i < 2; i++){ //Clear read buffer because the RFM95W sends register contents even during writes
 c38:	8f 5f       	subi	r24, 0xFF	; 255
 c3a:	82 30       	cpi	r24, 0x02	; 2
 c3c:	d8 f3       	brcs	.-10     	; 0xc34 <rfmSpiRecv+0x20>
		temp = (u8) SPI0.DATA;
	}
	u8 data = spiRecv();
 c3e:	0e 94 e4 05 	call	0xbc8	; 0xbc8 <spiRecv>
 c42:	c8 2f       	mov	r28, r24
	digitalWrite(RFM_SS, 1);
 c44:	60 91 a1 60 	lds	r22, 0x60A1	; 0x8060a1 <RFM_SS>
 c48:	70 91 a2 60 	lds	r23, 0x60A2	; 0x8060a2 <RFM_SS+0x1>
 c4c:	80 91 a3 60 	lds	r24, 0x60A3	; 0x8060a3 <RFM_SS+0x2>
 c50:	41 e0       	ldi	r20, 0x01	; 1
 c52:	0e 94 a6 02 	call	0x54c	; 0x54c <digitalWrite>
	return data; 
}
 c56:	8c 2f       	mov	r24, r28
 c58:	cf 91       	pop	r28
 c5a:	08 95       	ret

00000c5c <rfmSpiSend>:
	SPI0_INTFLAGS = 0xC0; //Reset Interrupts
	return data;
	
}

void rfmSpiSend(u8 addr, u8 data){
 c5c:	1f 93       	push	r17
 c5e:	cf 93       	push	r28
 c60:	df 93       	push	r29
 c62:	c8 2f       	mov	r28, r24
 c64:	16 2f       	mov	r17, r22
	u8 temp;
	digitalWrite(RFM_SS, 0);
 c66:	60 91 a1 60 	lds	r22, 0x60A1	; 0x8060a1 <RFM_SS>
 c6a:	70 91 a2 60 	lds	r23, 0x60A2	; 0x8060a2 <RFM_SS+0x1>
 c6e:	80 91 a3 60 	lds	r24, 0x60A3	; 0x8060a3 <RFM_SS+0x2>
 c72:	40 e0       	ldi	r20, 0x00	; 0
 c74:	0e 94 a6 02 	call	0x54c	; 0x54c <digitalWrite>
	
	spiSend(RFM_SPI_WRITE | addr);
 c78:	8c 2f       	mov	r24, r28
 c7a:	80 68       	ori	r24, 0x80	; 128
 c7c:	0e 94 fc 05 	call	0xbf8	; 0xbf8 <spiSend>
	//Clear read buffer because the RFM95W sends register contents even during writes
	temp = (u8) SPI0.DATA;
 c80:	c0 e4       	ldi	r28, 0x40	; 64
 c82:	d9 e0       	ldi	r29, 0x09	; 9
 c84:	8c 81       	ldd	r24, Y+4	; 0x04
	
	spiSend(data);
 c86:	81 2f       	mov	r24, r17
 c88:	0e 94 fc 05 	call	0xbf8	; 0xbf8 <spiSend>
	//Clear read buffer because the RFM95W sends register contents even during writes
	temp = (u8) SPI0.DATA;
 c8c:	8c 81       	ldd	r24, Y+4	; 0x04
	
	digitalWrite(RFM_SS, 1);
 c8e:	60 91 a1 60 	lds	r22, 0x60A1	; 0x8060a1 <RFM_SS>
 c92:	70 91 a2 60 	lds	r23, 0x60A2	; 0x8060a2 <RFM_SS+0x1>
 c96:	80 91 a3 60 	lds	r24, 0x60A3	; 0x8060a3 <RFM_SS+0x2>
 c9a:	41 e0       	ldi	r20, 0x01	; 1
 c9c:	0e 94 a6 02 	call	0x54c	; 0x54c <digitalWrite>
	SPI0_INTFLAGS = 0xC0;
 ca0:	80 ec       	ldi	r24, 0xC0	; 192
 ca2:	80 93 43 09 	sts	0x0943, r24	; 0x800943 <__TEXT_REGION_LENGTH__+0x7f0943>
}
 ca6:	df 91       	pop	r29
 ca8:	cf 91       	pop	r28
 caa:	1f 91       	pop	r17
 cac:	08 95       	ret

00000cae <_exit>:
 cae:	f8 94       	cli

00000cb0 <__stop_program>:
 cb0:	ff cf       	rjmp	.-2      	; 0xcb0 <__stop_program>
